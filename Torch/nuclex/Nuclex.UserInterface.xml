<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nuclex.UserInterface</name>
    </assembly>
    <members>
        <member name="T:Nuclex.UserInterface.Resources.SuaveSkinResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.Resources.SuaveSkinResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.Resources.SuaveSkinResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Resources.SuaveSkinResourcesTest">
            <summary>Unit tests for the debug drawer resources</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.SuaveSkinResourcesTest.TestResourceClassCreation">
            <summary>Verifies that an instance of the resource class can be created</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.SuaveSkinResourcesTest.TestAssignCulture">
            <summary>Tests the 'Culture' property of the resource class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.SuaveSkinResourcesTest.TestDefaultFont">
            <summary>Verifies that the default font can be accessed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.SuaveSkinResourcesTest.TestTitleFont">
            <summary>Verifies that the title font can be accessed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.SuaveSkinResourcesTest.TestSuaveSheet">
            <summary>Verifies that the GUI element sprite sheet can be accessed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.SuaveSkinResourcesTest.TestSuaveSkin">
            <summary>Verifies that the XML skin description can be accessed</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Resources.UnitTestResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.Resources.UnitTestResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.Resources.UnitTestResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Resources.DebugDrawerResourcesTest">
            <summary>Unit tests for the debug drawer resources</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.DebugDrawerResourcesTest.TestResourceClassCreation">
            <summary>Verifies that an instance of the resource class can be created</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.DebugDrawerResourcesTest.TestAssignCulture">
            <summary>Tests the 'Culture' property of the resource class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.DebugDrawerResourcesTest.TestUnitTestFont">
            <summary>Verifies that the unit test sprite font can be accessed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.DebugDrawerResourcesTest.TestUnitTestSkin">
            <summary>Verifies that the unit test skin can be accessed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.DebugDrawerResourcesTest.TestBadColorSkin">
            <summary>Verifies that the bad color skin can be accessed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.DebugDrawerResourcesTest.TestBadHorizontalPositionSkin">
            <summary>Verifies that the bad horizontal position skin can be accessed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Resources.DebugDrawerResourcesTest.TestBadVerticalPositionSkin">
            <summary>Verifies that the bad vertical position skin can be accessed</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.DesktopControl">
            <summary>Control used to represent the desktop</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Control">
            <summary>Represents an element in the user interface</summary>
            <remarks>
              <para>
                Controls are always arranged in a tree where each control except the one at
                the root of the tree has exactly one owner (the one at the root has no owner).
                The design actively prevents you from assigning a control as child to
                multiple parents.
              </para>
              <para>
                The controls in the Nuclex.UserInterface library are fully independent of
                their graphical representation. That means you can construct a dialog
                without even having a graphics device in place, that you can move your
                dialogs between different graphics devices and that you do not have to
                even think about graphics device resets and similar trouble.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessButtonPress(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad has been pressed</summary>
            <param name="button">Button that has been pressed</param>
            <returns>
              True if the button press was processed by the control and future game pad
              input belongs to the control until all buttons are released again
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessButtonRelease(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad has been released</summary>
            <param name="button">Button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessMouseLeave">
            <summary>
              Called when the mouse has left the control and is no longer hovering over it
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessMousePress(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
            <returns>Whether the control has processed the mouse press</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessMouseRelease(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessMouseMove(System.Single,System.Single,System.Single,System.Single)">
            <summary>Processes mouse movement notifications</summary>
            <param name="containerWidth">Absolute width of the control's container</param>
            <param name="containerHeight">Absolute height of the control's container</param>
            <param name="x">Absolute X position of the mouse within the container</param>
            <param name="y">Absolute Y position of the mouse within the container</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessMouseWheel(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks that the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessKeyPress(Microsoft.Xna.Framework.Input.Keys,System.Boolean)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
            <param name="repetition">
              Whether the key press is due to the user holding down a key
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessKeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released again</summary>
            <param name="keyCode">Code of the key that was released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.switchMouseOverControl(Nuclex.UserInterface.Controls.Control)">
            <summary>Switches the mouse over control to a different control</summary>
            <param name="newMouseOverControl">New control the mouse is hovering over</param>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.heldMouseButtons">
            <summary>Mouse buttons the user is holding down over the control</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.heldKeyCount">
            <summary>Number of keyboard keys being held down</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.heldButtonCount">
            <summary>Number of game pad buttons being held down</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.mouseOverControl">
            <summary>Control the mouse is currently hovering over</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.activatedControl">
            <summary>Control the mouse was pressed down on</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.#ctor">
            <summary>Initializes a new control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.#ctor(System.Boolean)">
            <summary>Initializes a new control</summary>
            <param name="affectsOrdering">
              Whether the control comes to the top of the hierarchy when clicked
            </param>
            <remarks>
              <para>
                The <paramref name="affectsOrdering" /> parameter should be set for windows
                and other free-floating panels which exist in parallel and which the user
                might want to put on top of their siblings by clicking them. If the user
                clicks on a child control of such a panel/window control, the panel/window
                control will also be moved into the foreground.
              </para>
              <para>
                It should not be set for normal controls which usually have no overlap,
                like buttons. Otherwise, a button placed on the desktop could overdraw a
                window when the button is clicked. The behavior would be well-defined and
                controlled, but the user probably doesn't expect this ;-)
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.BringToFront">
            <summary>Moves the control into the foreground</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.GetAbsoluteBounds">
            <summary>
              Obtains the absolute boundaries of the control in screen coordinates
            </summary>
            <returns>The control's absolute screen coordinate boundaries</returns>
            <remarks>
              This method resolves the unified coordinates into absolute screen coordinates
              that can be used to do hit-testing and rendering. The control is required to
              be part of a GUI hierarchy that is assigned to a screen for this to work
              since otherwise, there's no absolute coordinate frame into which the
              unified coordinates could be resolved.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnCommand(Nuclex.UserInterface.Input.Command)">
            <summary>Called when an input command was sent to the control</summary>
            <param name="command">Input command that has been triggered</param>
            <returns>Whether the command has been processed by the control</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been pressed</summary>
            <param name="button">Button that has been pressed</param>
            <returns>
              True if the button press was handled by the control, otherwise false.
            </returns>
            <remarks>
              If the control indicates that it didn't handle the key press, it will not
              receive the associated key release notification.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been released</summary>
            <param name="button">Button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnMouseMoved(System.Single,System.Single)">
            <summary>Called when the mouse position is updated</summary>
            <param name="x">X coordinate of the mouse cursor on the control</param>
            <param name="y">Y coordinate of the mouse cursor on the control</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnMousePressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
            <returns>Whether the control has processed the mouse press</returns>
            <remarks>
              If this method states that a mouse press is processed by returning
              true, that means the control did something with it and the mouse press
              should not be acted upon by any other listener.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnMouseReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnMouseLeft">
            <summary>
              Called when the mouse has left the control and is no longer hovering over it
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnMouseEntered">
            <summary>
              Called when the mouse has entered the control and is now hovering over it
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnMouseWheel(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks that the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
            <returns>
              True if the key press was handled by the control, otherwise false.
            </returns>
            <remarks>
              If the control indicates that it didn't handle the key press, it will not
              receive the associated key release notification. This means that if you
              return false from this method, you should under no circumstances do anything
              with the information - you will not know when the key is released again
              and another control might pick it up, causing a second key response.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released again</summary>
            <param name="keyCode">Code of the key that was released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.ProcessCommand(Nuclex.UserInterface.Input.Command)">
            <summary>Called when a command was sent to the control</summary>
            <param name="command">Command to be injected</param>
            <returns>Whether the command has been processed</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.SetParent(Nuclex.UserInterface.Controls.Control)">
            <summary>Assigns a new parent to the control</summary>
            <param name="parent">New parent to assign to the control</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Control.SetScreen(Nuclex.UserInterface.Screen)">
            <summary>Assigns a new GUI to the control</summary>
            <param name="gui">New GUI to assign to the control</param>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.Bounds">
            <summary>Location and extents of the control</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.parent">
            <summary>Control this control is contained in</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.screen">
            <summary>GUI instance this control has been added to. Can be null.</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.name">
            <summary>Name of the control instance (for programmatic identification)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.affectsOrdering">
            <summary>Whether this control can obtain the input focus</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Control.children">
            <summary>Child controls belonging to this control</summary>
            <remarks>
              Child controls are any controls that belong to this control. They don't
              neccessarily need to be situated in this control's client area, but
              their positioning will be relative to the parent's location.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Control.anyKeysOrButtonsPressed">
            <summary>
              Whether any keys, mouse buttons or game pad buttons are beind held pressed
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Control.Children">
            <summary>Children of the control</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Control.AffectsOrdering">
            <summary>
              True if clicking the control or its children moves the control into
              the foreground of the drawing hierarchy
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Control.Parent">
            <summary>Parent control this control is contained in</summary>
            <remarks>
              Can be null, but this is only the case for free-floating controls that have
              not been added into a Gui. The only control that really keeps this field
              set to null whilst the Gui is active is the root control in the Gui class.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Control.Name">
            <summary>Name that can be used to uniquely identify the control</summary>
            <remarks>
              This name acts as an unique identifier for a control. It primarily serves
              as a means to programmatically identify the control and as a debugging aid.
              Duplicate names are not allowed and will result in an exception being
              thrown, the only exception is when the control's name is set to null.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Control.Screen">
            <summary>GUI instance this control belongs to. Can be null.</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Control.MouseOverControl">
            <summary>Control the mouse is currently over</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Control.ActivatedControl">
            <summary>Control that currently captured incoming input</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.DesktopControl.#ctor">
            <summary>Initializes a new control</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.DesktopControl.IsMouseOverGui">
            <summary>True if the mouse is currently hovering over a GUI element</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.DesktopControl.IsInputCaptured">
            <summary>Whether the GUI holds ownership of the input devices</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.IFocusable">
            <summary>Interface for controls which can obtain the input focus</summary>
            <remarks>
              Implement this interface in any control which can obtain the input focus.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.IFocusable.CanGetFocus">
            <summary>
              Whether the control can currently obtain the input focus
            </summary>
            <remarks>
              Usually returns true. For controls that can be disabled to disallow user
              interaction, false can be returned to prevent the control from being
              traversed when the user presses the tab key or uses the cursor / game pad
              to select a control.
            </remarks>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.PressableControlTest">
            <summary>Unit Test for the pressable control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestPressByMouse">
            <summary>Verifies whether the control can be pressed using the mouse</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestLastSecondAbortByMouse">
            <summary>
              Tests whether a press can be aborted at the last second by moving
              the mouse away from the control before the mouse button is released
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestPressDisabledControl">
            <summary>Ensures that a disabled control cannot be pressed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestPressWithSpaceBar">
            <summary>
              Verifies that the pressable control can be pressed using the space bar
              if it is in focus
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestIgnoredKeys">
            <summary>
              Verifies that pressed keys are replayed to a control if those keys have been
              ignore before but now account to the control because it has been activated.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestThrowOnInvalidCommand">
            <summary>
              Verifies that sending an invalid command to a control causes an exception
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestShortcutByGamepad">
            <summary>
              Verifies that the pressable control can be operated by the game pad
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestShortcutByKeyboard(Microsoft.Xna.Framework.Input.Buttons,Microsoft.Xna.Framework.Input.Keys)">
            <summary>
              Tests whether the pressable control can be operated by the keyboard
            </summary>
            <param name="button">Shortcut button that will be assigned to the control</param>
            <param name="key">Equivalent key on the keyboard for the shortcut button</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestIgnoreInvalidShortcut">
            <summary>
              Verifies that the control ignores an invalid shortcut button
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestShortcutAssignment">
            <summary>
              Verifies that a shortcut button can be assigned to the control
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.PressableControlTest.TestPressableControl">
            <summary>
              Test implementation of a pressable control used in the unit tests
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.PressableControl">
            <summary>User interface element the user can push down</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.#ctor">
            <summary>Initializes a new command control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.OnMouseEntered">
            <summary>
              Called when the mouse has entered the control and is now hovering over it
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.OnMouseLeft">
            <summary>
              Called when the mouse has left the control and is no longer hovering over it
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.OnMousePressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.OnMouseReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.OnButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been pressed</summary>
            <param name="button">Button that has been pressed</param>
            <returns>
              True if the button press was handled by the control, otherwise false.
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.OnButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been released</summary>
            <param name="button">Button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
            <returns>
              True if the key press was handled by the control, otherwise false.
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released again</summary>
            <param name="keyCode">Code of the key that was released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.OnPressed">
            <summary>Called when the control is pressed</summary>
            <remarks>
              If you were to implement a button, for example, you could trigger a 'Pressed'
              event here are call a user-provided delegate, depending on your design.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControl.keyFromButton(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Looks up the equivalent key to the gamepad button</summary>
            <param name="button">
              Gamepad button for which the equivalent key on the keyboard will be found
            </param>
            <returns>The key that is equivalent to the specified gamepad button</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.PressableControl.Enabled">
            <summary>Whether the user can interact with the choice</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.PressableControl.ShortcutButton">
            <summary>Button that can be pressed to activate this command</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.PressableControl.pressedDownByKeyboard">
            <summary>Whether the command is pressed down using the space key</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.PressableControl.pressedDownByKeyboardShortcut">
            <summary>Whether the command is pressed down using the keyboard shortcut</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.PressableControl.pressedDownByGamepadShortcut">
            <summary>Whether the command is pressed down using the game pad shortcut</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.PressableControl.pressedDownByMouse">
            <summary>Whether the command is pressed down using the mouse</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.PressableControl.mouseHovering">
            <summary>Whether the mouse is hovering over the command</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.PressableControl.MouseHovering">
            <summary>Whether the mouse pointer is hovering over the control</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.PressableControl.Depressed">
            <summary>Whether the pressable control is in the depressed state</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.PressableControl.HasFocus">
            <summary>Whether the control currently has the input focus</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.PressableControl.Nuclex#UserInterface#Controls#IFocusable#CanGetFocus">
            <summary>Whether the control can currently obtain the input focus</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.PressableControlTest.TestPressableControl.OnPressed">
            <summary>Called when the control is pressed</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.PressableControlTest.TestPressableControl.PressCount">
            <summary>Number of times the button was pressed</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ProgressControl">
            <summary>Visual indicator for the progress of some operation</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ProgressControl.Progress">
            <summary>The displayed progress in the range between 0.0 and 1.0</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ControlEventArgs">
            <summary>Event argument class that carries a control instance</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlEventArgs.#ctor(Nuclex.UserInterface.Controls.Control)">
            <summary>Initializes a new control event args instance</summary>
            <param name="control">Control to provide to the subscribers of the event</param>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ControlEventArgs.control">
            <summary>Control that will be accessible to the event subscribers</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.ControlEventArgs.Control">
            <summary>Control that has been provided for the event</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Arcade.PanelControl">
            <summary>Panel that can host other controls, similar to a window</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ControlTest">
            <summary>Unit Test for the control class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestNameCollisionOnIdAssignment">
            <summary>
              Tests whether the control detects an id collision with one of its siblings
              when the id is assigned to an already used string.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestNameCollisionOnInsertion">
            <summary>
              Tests whether the control detects an id collision with one of its siblings
              when a sibling is added that has the same name.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestUnsupportedCommands">
            <summary>Verifies that the control rejects unsupported commands</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestSupportedCommands">
            <summary>Verifies that the control accepts supported commands</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestAbsoluteCoordinateTransformation">
            <summary>
              Validates that the control can correctly resolve its unified coordinates
              into absolute screen coordinates if parented to a screen.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestThrowsOnGetAbsolutePositionWithoutScreen">
            <summary>
              Verifies that the control throws an exception if it is asked to provide its
              absolute position within being connected to a screen.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestBringToFront">
            <summary>
              Tests whether a control can be brought to the front of the drawing hierarchy
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestInitialMousePressOutsideOfControl">
            <summary>
              Verifies that mouse presses outside of the control's area can be handled
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestMouseOver">
            <summary>
              Ensures that the control can handle mouse over notifications if its notification
              is not overridden and it has no children
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestMouseOverChildren">
            <summary>
              Ensures that the control passes on mouse over notifications to its children
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestMouseOverWithActivatedControl">
            <summary>
              Ensures that the control passes mouse movement notifications to the activated
              control first.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestIgnoreMousePress">
            <summary>
              Ensures that a control with no overridden methods mouse presses are ignored
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestReorderControlsOnMousePress">
            <summary>
              Verifies that order-affecting controls are reordered when the user clicks
              on a control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestMouseWheelWithActivatedControl">
            <summary>
              Verifies that mouse wheel turns are delivered to the activated control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestMouseWheelWithMouseOverControl">
            <summary>
              Verifies that mouse wheel turns are delivered to the control the mouse
              is over when no control is activated
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestKeyPressWithActivatedControl">
            <summary>
              Verifies that keyboard messages are routed to the activated control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestKeyPressOnFocusAffectingControl">
            <summary>
              Verifies that keyboard messages are only sent to the foreground window 
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestButtonPressWithActivatedControl">
            <summary>
              Verifies that game pad messages are routed to the activated control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.TestButtonPressOnFocusAffectingControl">
            <summary>
              Verifies that game pad messages are only sent to the foreground window 
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.assertAlmostEqual(System.Single,System.Single)">
            <summary>Asserts that two floating point values are almost equal</summary>
            <param name="expected">Expected value</param>
            <param name="actual">Actual value</param>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ControlTest.MouseOverTestControl">
            <summary>Control used for testing the mouse over notifications</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.MouseOverTestControl.OnMouseEntered">
            <summary>
              Called when the mouse has entered the control and is now hovering over it
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.MouseOverTestControl.OnMouseLeft">
            <summary>
              Called when the mouse has left the control and is no longer hovering over it
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ControlTest.MouseOverTestControl.MouseOver">
            <summary>Whether the mouse is currently hovering over the control</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ControlTest.MouseWheelTestControl">
            <summary>Control used for testing the mouse wheel notification</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.MouseWheelTestControl.OnMouseWheel(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks that the mouse wheel has been rotated</param>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ControlTest.MouseWheelTestControl.Ticks">
            <summary>Number of ticks the mouse wheel has been moved</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ControlTest.KeyboardTestControl">
            <summary>Control used for testing the keyboard notification</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.KeyboardTestControl.#ctor(System.Boolean)">
            <summary>Initializes a new keyboard test control</summary>
            <param name="responsible">
              Whether the control will claim responsibility for input routed to it
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.KeyboardTestControl.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
            <returns>
              True if the key press was handled by the control, otherwise false.
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.KeyboardTestControl.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released again</summary>
            <param name="keyCode">Code of the key that was released</param>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ControlTest.KeyboardTestControl.HeldKeyCount">
            <summary>Number of keys being held down</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ControlTest.KeyboardTestControl.responsible">
            <summary>
              Whether the control claims responsibility for input routed to it
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ControlTest.GamePadTestControl">
            <summary>Control used for testing the keyboard notification</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.GamePadTestControl.#ctor(System.Boolean)">
            <summary>Initializes a new keyboard test control</summary>
            <param name="responsible">
              Whether the control will claim responsibility for input routed to it
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.GamePadTestControl.OnButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been pressed</summary>
            <param name="button">Button that has been pressed</param>
            <returns>
              True if the button press was handled by the control, otherwise false.
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlTest.GamePadTestControl.OnButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been released</summary>
            <param name="button">Button that has been released</param>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ControlTest.GamePadTestControl.HeldButtonCount">
            <summary>Number of keys being held down</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ControlTest.GamePadTestControl.responsible">
            <summary>
              Whether the control claims responsibility for input routed to it
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ControlEventArgsTest">
            <summary>Unit Test for the control event argument container</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlEventArgsTest.TestNullControl">
            <summary>
              Tests whether a null control can be carried by the event argument container
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ControlEventArgsTest.TestNormalControl">
            <summary>
              Tests whether a control can be carried by the event argument container
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ButtonControl">
            <summary>Pushable button that can initiate an action</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ButtonControl.OnPressed">
            <summary>Called when the button is pressed</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ButtonControl.Text">
            <summary>Text that will be shown on the button</summary>
        </member>
        <member name="E:Nuclex.UserInterface.Controls.Desktop.ButtonControl.Pressed">
            <summary>Will be triggered when the button is pressed</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ButtonControlTest">
            <summary>Unit Test for the button control class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ButtonControlTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ButtonControlTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ButtonControlTest.TestButtonPressByMouse">
            <summary>Verifies whether the button can be pressed using the mouse</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ButtonControlTest.TestLastSecondAbortByMouse">
            <summary>
              Tests whether a button press can be aborted at the last second by moving
              the mouse away from the button before the mouse button is released
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ButtonControlTest.mockSubscriber(Nuclex.UserInterface.Controls.Desktop.ButtonControl)">
            <summary>Mocks a subscriber for the events of a button</summary>
            <param name="button">Button to mock an event subscriber for</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ButtonControlTest.mockery">
            <summary>Manages mocked interfaces and verifies expectations</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ButtonControlTest.IButtonSubscriber">
            <summary>Interface for a subscriber to the button control's events</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ButtonControlTest.IButtonSubscriber.Pressed(System.Object,System.EventArgs)">
            <summary>Called when the button control is pressed</summary>
            <param name="sender">Button control that has been pressed</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ChoiceControl">
            <summary>Control displaying an exclusive choice the user can select</summary>
            <remarks>
              The choice control is equivalent to a radio button - if more than one
              choice control is on a dialog, only one can be selected at a time.
              To have several choice groups on a dialog, use panels to group them.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControl.OnPressed">
            <summary>Called when the button is pressed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControl.OnChanged">
            <summary>Triggers the changed event</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControl.unselectSiblings">
            <summary>Disables all sibling choices on the same level</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ChoiceControl.Text">
            <summary>Text that will be shown on the button</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ChoiceControl.Selected">
            <summary>Whether the choice is currently selected</summary>
        </member>
        <member name="E:Nuclex.UserInterface.Controls.Desktop.ChoiceControl.Changed">
            <summary>Will be triggered when the choice is changed</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest">
            <summary>Unit Test for the choice control class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.TestChoiceWithoutParent">
            <summary>Verifies that the option can work without a parent</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.TestClickOnSelectedChoice">
            <summary>
              Verifies that a selected choice remains selected if the user clicks on it
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.TestToggleChoicesByMouse">
            <summary>
              Verifies that all other choices in the same parent are disabled when
              a choice is clicked on
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.TestLastSecondAbortByMouse">
            <summary>
              Tests whether a choice click can be aborted at the last second by moving
              the mouse away from the choice before the mouse button is released
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.mockSubscriber(Nuclex.UserInterface.Controls.Desktop.ChoiceControl)">
            <summary>Mocks a subscriber for the events of a choice</summary>
            <param name="choice">Choice to mock an event subscriber for</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.mockery">
            <summary>Manages mocked interfaces and verifies expectations</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.parent">
            <summary>Parent control the choice controls are contained in</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.child1">
            <summary>First choice control in the parent</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.child2">
            <summary>Second choice control in the parent</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.IChoiceSubscriber">
            <summary>Interface for a subscriber to the choice control's events</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ChoiceControlTest.IChoiceSubscriber.Changed(System.Object,System.EventArgs)">
            <summary>Called when the choice control's state changes</summary>
            <param name="sender">Choice control whose state has changed</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.CloseWindowButtonControl">
            <summary>Control for the X button in the top right corner of a window</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ClosewindowButtonControlTest">
            <summary>Unit Test for the close window button</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ClosewindowButtonControlTest.TestConstructor">
            <summary>
              Verifies that instances of the close window button can be created
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.DraggableControlTest">
            <summary>Unit Test for the draggable control base class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControlTest.TestDefaultConstructor">
            <summary>
              Tests whether the default constructor of the draggable control is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControlTest.TestFullConstructor">
            <summary>
              Tests whether the full constructor of the draggable control is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControlTest.TestDragging">
            <summary>Tests whether the control can be dragged using the mouse</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControlTest.DisableDragging">
            <summary>
              Tests whether the dragging capability can be disabled for a window
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.DraggableControlTest.DummyDraggableControl">
            <summary>Dummy implementation of a draggable control</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.DraggableControl">
            <summary>Control the user can drag around with the mouse</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControl.#ctor">
            <summary>Initializes a new draggable control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControl.#ctor(System.Boolean)">
            <summary>Initializes a new draggable control</summary>
            <param name="canGetFocus">Whether the control can obtain the input focus</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControl.OnMouseMoved(System.Single,System.Single)">
            <summary>Called when the mouse position is updated</summary>
            <param name="x">X coordinate of the mouse cursor on the GUI</param>
            <param name="y">Y coordinate of the mouse cursor on the GUI</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControl.OnMousePressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControl.OnMouseReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.DraggableControl.enableDragging">
            <summary>Whether the control can be dragged</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.DraggableControl.beingDragged">
            <summary>Whether the control is currently being dragged</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.DraggableControl.pickupX">
            <summary>X coordinate at which the control was picked up</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.DraggableControl.pickupY">
            <summary>Y coordinate at which the control was picked up</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.DraggableControl.EnableDragging">
            <summary>Whether the control can be dragged with the mouse</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControlTest.DummyDraggableControl.#ctor">
            <summary>Initializes a new draggable control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.DraggableControlTest.DummyDraggableControl.#ctor(System.Boolean)">
            <summary>Initializes a new draggable control</summary>
            <param name="canGetFocus">Whether the control can obtain the input focus</param>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.DraggableControlTest.DummyDraggableControl.EnableDragging">
            <summary>Whether the control can be dragged by the mouse</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControl">
            <summary>Horizontal slider that can be moved using the mouse</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.SliderControl">
            <summary>Base class for a slider that can be moved using the mouse</summary>
            <remarks>
              Implements the common functionality for a slider moving either the direction
              of the X or the Y axis (but not both). Derive any scroll bar-like controls
              from this class to simplify their implementation.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControl.#ctor">
            <summary>Initializes a new slider control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControl.OnMousePressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControl.OnMouseReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControl.OnMouseMoved(System.Single,System.Single)">
            <summary>Called when the mouse position is updated</summary>
            <param name="x">X coordinate of the mouse cursor on the control</param>
            <param name="y">Y coordinate of the mouse cursor on the control</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControl.OnMouseLeft">
            <summary>
              Called when the mouse has left the control and is no longer hovering over it
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControl.OnMoved">
            <summary>Fires the slider's Moved event</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControl.MoveThumb(System.Single,System.Single)">
            <summary>Moves the thumb to the specified location</summary>
            <returns>Location the thumb will be moved to</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControl.GetThumbRegion">
            <summary>Obtains the region covered by the slider's thumb</summary>
            <returns>The region covered by the slider's thumb</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControl.ThumbLocator">
            <summary>Can be set by renderers to allow the control to locate its thumb</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControl.ThumbSize">
            <summary>Fraction of the slider filled by the thumb (0.0 .. 1.0)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControl.ThumbPosition">
            <summary>Position of the thumb within the slider (0.0 .. 1.0)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControl.mouseOverThumb">
            <summary>Whether the mouse cursor is hovering over the thumb</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControl.pressedDown">
            <summary>Whether the slider's thumb is currently in the depressed state</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControl.pickupX">
            <summary>X coordinate at which the thumb was picked up</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControl.pickupY">
            <summary>Y coordinate at which the thumb was picked up</summary>
        </member>
        <member name="E:Nuclex.UserInterface.Controls.Desktop.SliderControl.Moved">
            <summary>Triggered when the slider has been moved</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.SliderControl.MouseOverThumb">
            <summary>whether the mouse is currently hovering over the thumb</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.SliderControl.ThumbDepressed">
            <summary>Whether the pressable control is in the depressed state</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControl.GetThumbRegion">
            <summary>Obtains the region covered by the slider's thumb</summary>
            <returns>The region covered by the slider's thumb</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControl.MoveThumb(System.Single,System.Single)">
            <summary>Moves the thumb to the specified location</summary>
            <returns>Location the thumb will be moved to</returns>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControlTest">
            <summary>Unit Test for the horizontal slider</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControlTest.TestMouseOverThumb">
            <summary>
              Verifies that the slider can detect when the mouse cursor is over its thumb
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControlTest.TestMouseOverWithThumbLocator">
            <summary>
              Verifies that the slider can detect when the mouse cursor is over its thumb
              using a thumb locator
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControlTest.TestThumbDragging">
            <summary>
              Verifies that the mouse can be used to drag the slider's thumb
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControlTest.TestFullSizeThumbDragging">
            <summary>
              Verifies that no errors occur when the user attempts to drag a thumb that
              fills out the whole slider.
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControlTest.DummyThumbLocator">
            <summary>Dummy thumb locator returning a fixed location</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.IThumbLocator">
            <summary>
              Interface which can be established between a control and its renderer to
              allow a slider control to locate its thumb
            </summary>
            <remarks>
              A renderer can implement this interface and assign it to a control that
              it renders so the control can ask the renderer for extended informations
              regarding the look of its text. If this interface is provided, certain
              controls will be able to correctly place the caret in user-editable text
              when they are clicked by the mouse.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.IThumbLocator.GetThumbPosition(Nuclex.UserInterface.RectangleF,System.Single,System.Single)">
            <summary>
              Calculates the position of the thumb on a slider
            </summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <param name="thumbPosition">Relative position of the thumb (0.0 .. 1.0)</param>
            <param name="thumbSize">Relative size of the thumb (0.0 .. 1.0)</param>
            <returns>The region covered by the slider's thumb</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControlTest.DummyThumbLocator.#ctor(Nuclex.UserInterface.RectangleF)">
            <summary>Initializes a new dummy thumb locator</summary>
            <param name="thumbArea">
              Area the locator will report the thumb to be in
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControlTest.DummyThumbLocator.GetThumbPosition(Nuclex.UserInterface.RectangleF,System.Single,System.Single)">
            <summary>
              Calculates the position of the thumb on a slider
            </summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <param name="thumbPosition">Relative position of the thumb (0.0 .. 1.0)</param>
            <param name="thumbSize">Relative size of the thumb (0.0 .. 1.0)</param>
            <returns>The region covered by the slider's thumb</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControlTest.DummyThumbLocator.ThumbArea">
            <summary>Area the thumb is reported to be in</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.IListRowLocator">
            <summary>
              Interface which can be established between a control and its renderer to
              allow a list control to locate the list row the cursor is in
            </summary>
            <remarks>
              A renderer can implement this interface and assign it to a control that
              it renders so the control can ask the renderer for extended informations
              regarding the look of its text. If this interface is provided, certain
              controls will be able to correctly place the caret in user-editable text
              when they are clicked by the mouse.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.IListRowLocator.GetRow(Nuclex.UserInterface.RectangleF,System.Single,System.Int32,System.Single)">
            <summary>Calculates the list row the cursor is in</summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <param name="thumbPosition">
              Position of the thumb in the list's slider
            </param>
            <param name="itemCount">
              Number of items contained in the list
            </param>
            <param name="y">Vertical position of the cursor</param>
            <returns>The row the cursor is over</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.IListRowLocator.GetRowHeight(Nuclex.UserInterface.RectangleF)">
            <summary>Determines the height of a row displayed in the list</summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <returns>The height of a single row in the list</returns>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.InputControlTest">
            <summary>Unit Test for the text input control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestSimpleInput">
            <summary>Verifies that simple text input is possible</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestGuideTitleAndDescription">
            <summary>
              Verifies that the title and description strings for the Guide can be assigned
              to the input control and queried via the IWritable interface
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestHomeAndEnd">
            <summary>
              Tests whether the caret can be moved by the home and end keys
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestCaretMovementByCursor">
            <summary>
              Tests whether the caret can be moved using the cursor keys
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestUnhandledKeyPress">
            <summary>
              Tests whether the input control rejects presses of keys it doesn't handle
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestUnfocusedKeyPress">
            <summary>
              Tests whether the input control rejects presses of normally handled keys
              when it isn't focused
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestBackspace">
            <summary>
              Verifies that the backspace key can be used to delete a character
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestDelete">
            <summary>
              Tests whether the delete key deletes the character right of the caret
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestTextShorteningAdjustsCaret">
            <summary>
              Tests whether assigning a text that is too short for the current caret
              position will adjust the caret's position
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestThrowOnInvalidCaretPosition">
            <summary>
              Verifies that an exception is thrown if an invalid caret position is assigned
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestInputFocus">
            <summary>
              Tests whether the control can tell whether it has the input focus
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestMoveCaretByMouseWithoutLocator">
            <summary>
              Verifies that the caret can be moved by clicking the mouse and that
              the input box performs its default action with no opening locator assigned.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestMoveCaretByMouseWitLocator">
            <summary>
              Verifies that the caret can be moved by clicking the mouse and that
              the input box uses its opening locator if it is assigned.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.TestMillisecondsSinceLastCaretMovement">
            <summary>
              Verifies that the input box tracks the milliseconds that have passed
              since the caret was last moved.
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.InputControlTest.DummyLocator">
            <summary>Dummy implementation of an opening locator</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.IOpeningLocator">
            <summary>
              Interface which can be established between a control and its renderer to
              allow the control to locate openings between letters
            </summary>
            <remarks>
              A renderer can implement this interface and assign it to a control that
              it renders so the control can ask the renderer for extended informations
              regarding the look of its text. If this interface is provided, certain
              controls will be able to correctly place the caret in user-editable text
              when they are clicked by the mouse.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.IOpeningLocator.GetClosestOpening(Nuclex.UserInterface.RectangleF,System.String,Microsoft.Xna.Framework.Vector2)">
            <summary>
              Calculates which opening between two letters is closest to a position
            </summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <param name="text">Text in which the nearest opening will be located</param>
            <param name="position">
              Position to which the closest opening will be found,
              should be in absolute coordinates
            </param>
            <returns>The index of the opening closest to the provided position</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.DummyLocator.#ctor(System.Int32)">
            <summary>Initializes a new dummy text opening locator</summary>
            <param name="index">Index of the opening the dummy locator will report</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControlTest.DummyLocator.GetClosestOpening(Nuclex.UserInterface.RectangleF,System.String,Microsoft.Xna.Framework.Vector2)">
            <summary>
              Calculates which opening between two letters is closest to a position
            </summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <param name="text">Text in which the nearest opening will be located</param>
            <param name="position">
              Position to which the closest opening will be found,
              should be in absolute coordinates
            </param>
            <returns>The index of the opening closest to the provided position</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControlTest.DummyLocator.index">
            <summary>Index the dummy locator will report</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ListSelectionMode">
            <summary>How the list lets the user select items</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ListSelectionMode.None">
            <summary>The user is not allowed to select an item</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ListSelectionMode.Single">
            <summary>The user can select only one item</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ListSelectionMode.Multi">
            <summary>The user can pick any number of items</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ListControl">
            <summary>List showing a sequence of items</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.#ctor">
            <summary>Initializes a new list box control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.OnMousePressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
            <remarks>
              If this method states that a mouse press is processed by returning
              true, that means the control did something with it and the mouse press
              should not be acted upon by any other listener.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.OnRowClicked(System.Int32)">
            <summary>Called when the user has clicked on a row in the list</summary>
            <param name="row">Row the user has clicked on</param>
            <remarks>
              The default behavior of the list control in multi select mode is to
              toggle items that are clicked between selected and unselected. If you
              need different behavior (for example, dragging a selected region or
              selecting sequences of items by holding the shift key), you can override
              this method and handle the selection behavior yourself.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.OnMouseWheel(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks that the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.OnMouseMoved(System.Single,System.Single)">
            <summary>Called when the mouse position is updated</summary>
            <param name="x">X coordinate of the mouse cursor on the control</param>
            <param name="y">Y coordinate of the mouse cursor on the control</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.OnSelectionChanged">
            <summary>Called when the selected items in the list have changed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.itemRemoved(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.String})">
            <summary>Called when an item is removed from the items list</summary>
            <param name="sender">List the item has been removed from</param>
            <param name="arguments">Contains the item that has been removed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.itemAdded(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.String})">
            <summary>Called when an item is added to the items list</summary>
            <param name="sender">List the item has been added to</param>
            <param name="arguments">Contains the item that has been added</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.itemsCleared(System.Object,System.EventArgs)">
            <summary>Called when the items list is about to clear itself</summary>
            <param name="sender">Items list that is about to clear itself</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.selectionAdded(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Int32})">
            <summary>Called when an entry is added to the list of selected items</summary>
            <param name="sender">List to which an item was added to</param>
            <param name="arguments">Contains the added item</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.selectionRemoved(System.Object,Nuclex.Support.Collections.ItemEventArgs{System.Int32})">
            <summary>
              Called when an entry is removed from the list of selected items
            </summary>
            <param name="sender">List from which an item was removed</param>
            <param name="arguments">Contains the removed item</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.selectionCleared(System.Object,System.EventArgs)">
            <summary>Called when the selected items list is about to clear itself</summary>
            <param name="sender">List that is about to clear itself</param>
            <param name="arguments">Not Used</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControl.updateSlider">
            <summary>Updates the size and position of the list's slider</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ListControl.listRowLocator">
            <summary>
              Row locator through which the list can detect which row the mouse has
              been pressed down on
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ListControl.mouseY">
            <summary>Last known Y coordinate of the mouse</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ListControl.selectionMode">
            <summary>How the list lets the user select from its items</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ListControl.items">
            <summary>Items contained in the list</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ListControl.selectedItems">
            <summary>Items currently selected in the list</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.ListControl.slider">
            <summary>Slider the lists uses to scroll through its items</summary>
        </member>
        <member name="E:Nuclex.UserInterface.Controls.Desktop.ListControl.SelectionChanged">
            <summary>Triggered when the selected items in list have changed</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.ListControl.SelectionMode">
            <summary>How the user can select items in the list</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.ListControl.Slider">
            <summary>Slider the list uses to scroll through its items</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.ListControl.Items">
            <summary>Items being displayed in the list</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.ListControl.SelectedItems">
            <summary>Indices of the items current selected in the list</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.ListControl.Nuclex#UserInterface#Controls#IFocusable#CanGetFocus">
            <summary>Whether the control can currently obtain the input focus</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.ListControl.ListRowLocator">
            <summary>
              Can be set by renderers to enable selection of list items by mouse
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ListControlTest">
            <summary>Unit Test for the list control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestConstructor">
            <summary>Initializes a new list control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestRowLocatorProperty">
            <summary>Verifies that the RowLocator property is working</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestDisabledSelectionByMouse">
            <summary>
              Tests whether list rows can be selected with the mouse in
              single-selection mode
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestSingleSelectionByMouse">
            <summary>
              Tests whether list rows can be selected with the mouse in
              single-selection mode
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestMultiSelectionByMouse">
            <summary>
              Tests whether list rows can be selected with the mouse in
              single-selection mode
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestSelectionModeProperty">
            <summary>Tests whether the selection mode of the list can be toggled</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestSliderProperty">
            <summary>Tests whether the list control provides access to its slider</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestSelectionChangedEvent">
            <summary>
              Tests whether the SelectionChanged event is fired when the selection changes
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestMouseWheel">
            <summary>Verifies that the list can be scrolled with the mouse wheel</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.TestSliderThumbResizing">
            <summary>
              Tests whether the slider's thumb resizes according to the list
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.mockSubscriber(NMock.MockFactory,Nuclex.UserInterface.Controls.Desktop.ListControl)">
            <summary>Mocks a subscriber for the events of a list</summary>
            <param name="mockery">Mockery through which the mock will be created</param>
            <param name="list">List to mock an event subscriber for</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.fillList(Nuclex.UserInterface.Controls.Desktop.ListControl,System.Int32)">
            <summary>Fills a list control with dummy items</summary>
            <param name="list">List control that will be filled</param>
            <param name="itemCount">Number of dummy items to generate</param>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ListControlTest.DummyListRowLocator">
            <summary>Dummy implementation of a list row locator</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.DummyListRowLocator.GetRow(Nuclex.UserInterface.RectangleF,System.Single,System.Int32,System.Single)">
            <summary>Calculates the list row the cursor is in</summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <param name="thumbPosition">
              Position of the thumb in the list's slider
            </param>
            <param name="itemCount">
              Number of items contained in the list
            </param>
            <param name="y">Vertical position of the cursor</param>
            <returns>The row the cursor is over</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.DummyListRowLocator.GetRowHeight(Nuclex.UserInterface.RectangleF)">
            <summary>Determines the height of a row displayed in the list</summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <returns>The height of a single row in the list</returns>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.ListControlTest.IListSubscriber">
            <summary>Interface for a subscriber to the list control's events</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.ListControlTest.IListSubscriber.SelectionChanged(System.Object,System.EventArgs)">
            <summary>Called when selection made in the list has changed</summary>
            <param name="sender">List whose selection has changed</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.OptionControl">
            <summary>Control displaying an option the user can toggle on and off</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.OptionControl.OnPressed">
            <summary>Called when the button is pressed</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.OptionControl.OnChanged">
            <summary>Triggers the changed event</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.OptionControl.Text">
            <summary>Text that will be shown on the button</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.OptionControl.Selected">
            <summary>Whether the option is currently selected</summary>
        </member>
        <member name="E:Nuclex.UserInterface.Controls.Desktop.OptionControl.Changed">
            <summary>Will be triggered when the choice is changed</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.OptionControlTest">
            <summary>Unit Test for the option control class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.OptionControlTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.OptionControlTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.OptionControlTest.TestOptionToggleByMouse">
            <summary>Verifies whether the option can be changed using the mouse</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.OptionControlTest.TestLastSecondAbortByMouse">
            <summary>
              Tests whether a button press can be aborted at the last second by moving
              the mouse away from the button before the mouse button is released
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.OptionControlTest.mockSubscriber(Nuclex.UserInterface.Controls.Desktop.OptionControl)">
            <summary>Mocks a subscriber for the events of an option</summary>
            <param name="option">Option to mock an event subscriber for</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.OptionControlTest.mockery">
            <summary>Manages mocked interfaces and verifies expectations</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.OptionControlTest.IOptionSubscriber">
            <summary>Interface for a subscriber to the option control's events</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.OptionControlTest.IOptionSubscriber.Changed(System.Object,System.EventArgs)">
            <summary>Called when the option control's state changes</summary>
            <param name="sender">Option control whose state has changed</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.InputControl">
            <summary>Control through which the user can enter text</summary>
            <remarks>
              <para>
                Through this control, users can be asked to enter an arbitrary string
                of characters, their name for example. Desktop users can enter text through
                their normal keyboard where Windows' own key translation is used to
                support regional settings and custom keyboard layouts.
              </para>
              <para>
                XBox 360 users will open the virtual keyboard when the input box gets
                the input focus and can add characters by selecting them from the virtual
                keyboard's character matrix.
              </para>
            </remarks>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.IWritable">
            <summary>
              Interface for controls that can be written into using the keyboard
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.IWritable.OnCharacterEntered(System.Char)">
            <summary>Called when the user has entered a character</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.IWritable.GuideTitle">
            <summary>Title to be displayed in the on-screen keyboard</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.IWritable.GuideDescription">
            <summary>Description to be displayed in the on-screen keyboard</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.IWritable.Text">
            <summary>Text currently contained in the control</summary>
            <remarks>
              Called before the on-screen keyboard is displayed to get the text currently
              contained in the control and after the on-screen keyboard has been
              acknowledged to assign the edited text to the control
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControl.#ctor">
            <summary>Initializes a new text input control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControl.OnCharacterEntered(System.Char)">
            <summary>Called when the user has entered a character</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControl.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
            <returns>
              True if the key press was handles by the control, otherwise false.
            </returns>
            <remarks>
              If the control indicates that it didn't handle the key press, it will not
              receive the associated key release notification.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControl.OnMouseMoved(System.Single,System.Single)">
            <summary>Called when the mouse position is updated</summary>
            <param name="x">X coordinate of the mouse cursor on the control</param>
            <param name="y">Y coordinate of the mouse cursor on the control</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControl.OnMousePressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControl.ProcessCharacter(System.Char)">
            <summary>Handles user text input by a physical keyboard</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControl.Nuclex#UserInterface#Controls#IWritable#OnCharacterEntered(System.Char)">
            <summary>Called when the user has entered a character</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControl.moveCaretToEnd">
            <summary>Moves the caret to the end of the text</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.InputControl.updateLastCaretMovementTicks">
            <summary>Updates the tick count when the caret was last moved</summary>
            <remarks>
              Used to prevent the caret from blinking when 
            </remarks>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.GuideTitle">
            <summary>Title to be displayed in the on-screen keyboard</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.GuideDescription">
            <summary>Description to be displayed in the on-screen keyboard</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.Enabled">
            <summary>Whether user interaction with the control is allowed</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.OpeningLocator">
            <summary>
              Can be set by renderers to enable cursor positioning by the mouse
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.singleCharArray">
            <summary>Array used to store characters before they are appended</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.lastCaretMovementTicks">
            <summary>Tick count at the time the caret was last moved</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.text">
            <summary>Text the user has entered into the text input control</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.caretPosition">
            <summary>Position of the cursor within the text</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.mouseX">
            <summary>X coordinate of the last known mouse position</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.InputControl.mouseY">
            <summary>Y coordinate of the last known mouse position</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.InputControl.Text">
            <summary>Text that is being displayed on the control</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.InputControl.CaretPosition">
            <summary>Position of the cursor within the text</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.InputControl.HasFocus">
            <summary>Whether the control currently has the input focus</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.InputControl.MillisecondsSinceLastCaretMovement">
            <summary>Elapsed milliseconds since the user last moved the caret</summary>
            <remarks>
              This is an unusual property for an input box to have. It is retrieved by
              the renderer and could be used for several purposes, such as lighting up
              a control when text is entered to provide better visual tracking or
              preventing the cursor from blinking whilst the user is typing.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.InputControl.Nuclex#UserInterface#Controls#IFocusable#CanGetFocus">
            <summary>Whether the control can currently obtain the input focus</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.InputControl.Nuclex#UserInterface#Controls#IWritable#GuideTitle">
            <summary>Title to be displayed in the on-screen keyboard</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.InputControl.Nuclex#UserInterface#Controls#IWritable#GuideDescription">
            <summary>Description to be displayed in the on-screen keyboard</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.SliderControlTest">
            <summary>Unit Test for the slider control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.TestConstructor">
            <summary>Verifies that the slider's constructor is working</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.TestMouseOverThumb">
            <summary>
              Verifies that the slider can detect when the mouse cursor is over its thumb
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.TestThumbPressing">
            <summary>
              Verifies that the mouse can press down the slider's thumb
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.TestThumbDragging">
            <summary>
              Verifies that the mouse can be used to drag the slider's thumb
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.TestRightClickProducesNoAction">
            <summary>Tests whether the slider ignores right-clicks</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.TestMoveEvent">
            <summary>Verifies that the slider can fire its 'Moved' event</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.mockSubscriber(NMock.MockFactory,Nuclex.UserInterface.Controls.Desktop.SliderControl)">
            <summary>Mocks a subscriber for the events of a slider</summary>
            <param name="mockery">Mockery through which the mock will be created</param>
            <param name="slider">Slider to mock an event subscriber for</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.ISliderSubscriber">
            <summary>Interface for a subscriber to the slider's events</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.ISliderSubscriber.Moved(System.Object,System.EventArgs)">
            <summary>Called when the slider's thumb has been moved</summary>
            <param name="sender">Slider whose thumb has been moved</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.DummySliderControl">
            <summary>Dummy implementation of a slider for unit testing</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.DummySliderControl.MoveThumb(System.Single,System.Single)">
            <summary>Moves the thumb to the specified location</summary>
            <returns>Location the thumb will be moved to</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.DummySliderControl.GetThumbRegion">
            <summary>Obtains the region covered by the slider's thumb</summary>
            <returns>The region covered by the slider's thumb</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.DummySliderControl.FireMoveEvent">
            <summary>Manually fires the slider's Moved event</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.DummySliderControl.ThumbX">
            <summary>Movement of the thumb on the X axis</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.DummySliderControl.ThumbY">
            <summary>Movement of the thumb on the Y axis</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.SliderControlTest.DummySliderControl.ReportedThumbRegion">
            <summary>Region the thumb is reported to be in</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControl">
            <summary>Vertical slider that can be moved using the mouse</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControl.GetThumbRegion">
            <summary>Obtains the region covered by the slider's thumb</summary>
            <returns>The region covered by the slider's thumb</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControl.MoveThumb(System.Single,System.Single)">
            <summary>Moves the thumb to the specified location</summary>
            <param name="x">X coordinate for the new left border of the thumb</param>
            <param name="y">Y coordinate for the new upper border of the thumb</param>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControlTest">
            <summary>Unit Test for the vertical slider</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControlTest.TestMouseOverThumb">
            <summary>
              Verifies that the slider can detect when the mouse cursor is over its thumb
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControlTest.TestMouseOverWithThumbLocator">
            <summary>
              Verifies that the slider can detect when the mouse cursor is over its thumb
              using a thumb locator
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControlTest.TestThumbDragging">
            <summary>
              Verifies that the mouse can be used to drag the slider's thumb
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControlTest.TestFullSizeThumbDragging">
            <summary>
              Verifies that no errors occur when the user attempts to drag a thumb that
              fills out the whole slider.
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControlTest.DummyThumbLocator">
            <summary>Dummy thumb locator returning a fixed location</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControlTest.DummyThumbLocator.#ctor(Nuclex.UserInterface.RectangleF)">
            <summary>Initializes a new dummy thumb locator</summary>
            <param name="thumbArea">
              Area the locator will report the thumb to be in
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControlTest.DummyThumbLocator.GetThumbPosition(Nuclex.UserInterface.RectangleF,System.Single,System.Single)">
            <summary>
              Calculates the position of the thumb on a slider
            </summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <param name="thumbPosition">Relative position of the thumb (0.0 .. 1.0)</param>
            <param name="thumbSize">Relative size of the thumb (0.0 .. 1.0)</param>
            <returns>The region covered by the slider's thumb</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.VerticalSliderControlTest.DummyThumbLocator.ThumbArea">
            <summary>Area the thumb is reported to be in</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.WindowControl">
            <summary>A window for hosting other controls</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.WindowControl.#ctor">
            <summary>Initializes a new window control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.WindowControl.Close">
            <summary>Closes the window</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.Desktop.WindowControl.Title">
            <summary>Text in the title bar of the window</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.WindowControl.IsOpen">
            <summary>Whether the window is currently open</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Controls.Desktop.WindowControl.EnableDragging">
            <summary>Whether the window can be dragged with the mouse</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.Desktop.WindowControlTest">
            <summary>Unit Test for the window control class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.WindowControlTest.TestWindowDragging">
            <summary>Tests whether the window can be dragged using the mouse</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.WindowControlTest.TestCloseUnopenedWindow">
            <summary>
              Tests whether the Close() method can be called when the window isn't open
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.WindowControlTest.TestOpenCloseWindow">
            <summary>
              Verifies that a window can be opened and closed again
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.Desktop.WindowControlTest.DisableDragging">
            <summary>
              Tests whether the dragging capability can be disabled for a window
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.LabelControl">
            <summary>Control that draws a block of text</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.LabelControl.#ctor">
            <summary>Initializes a new label control with an empty string</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.LabelControl.#ctor(System.String)">
            <summary>Initializes a new label control</summary>
            <param name="text">Text to be printed at the location of the label control</param>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.LabelControl.Text">
            <summary>Text to be rendered in the control's frame</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.LabelControlTest">
            <summary>Unit Test for the label control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.LabelControlTest.TestDefaultConstructor">
            <summary>
              Tests whether the default constructor of the label class is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.LabelControlTest.TestFullConstructor">
            <summary>
              Tests whether the full constructor of the label class is working
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ParentingControlCollection">
            <summary>Collection of GUI controls</summary>
            <remarks>
              This class is for internal use only. Do not expose it to the user. If it was
              exposed, the user might decide to use it for storing his own controls, causing
              exceptions because the collection tries to parent the controls which are already
              belonging to another collection.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.#ctor(Nuclex.UserInterface.Controls.Control)">
            <summary>Initializes a new parenting control collection</summary>
            <param name="parent">Parent control to assign to all children</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.ClearItems">
            <summary>Clears all elements from the collection</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.InsertItem(System.Int32,Nuclex.UserInterface.Controls.Control)">
            <summary>Inserts a new element into the collection</summary>
            <param name="index">Index at which to insert the element</param>
            <param name="item">Item to be inserted</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.RemoveItem(System.Int32)">
            <summary>Removes an element from the collection</summary>
            <param name="index">Index of the element to remove</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.SetItem(System.Int32,Nuclex.UserInterface.Controls.Control)">
            <summary>Takes over a new element that is directly assigned</summary>
            <param name="index">Index of the element that was assigned</param>
            <param name="item">New item</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.SetScreen(Nuclex.UserInterface.Screen)">
            <summary>Switches the control to a specific GUI</summary>
            <param name="screen">Screen that owns the control from now on</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.IsNameTaken(System.String)">
            <summary>
              Checks whether the provided name is already taken by a control
            </summary>
            <param name="name">Id that will be checked</param>
            <returns>True if the id is already taken, false otherwise</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.MoveToStart(System.Int32)">
            <summary>Moves the specified control to the start of the list</summary>
            <param name="controlIndex">
              Index of the control that will be moved to the start of the list
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.ensureIntegrity(Nuclex.UserInterface.Controls.Control)">
            <summary>Ensures the integrity of the parent/child relationships</summary>
            <param name="proposedChild">Control that is to become one of our childs</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.isParent(Nuclex.UserInterface.Controls.Control)">
            <summary>
              Determines whether the provided control is a parent of this control.
            </summary>
            <param name="control">Control to check for parentage</param>
            <returns>True if the control is one of our parents, otherwise false</returns>
            <remarks>
              This method takes into account all ancestors up to the tree's root.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.unassignParent(Nuclex.UserInterface.Controls.Control)">
            <summary>Gives up the parentage on the item provided</summary>
            <param name="item">Item to be unparented</param>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollection.assignParent(Nuclex.UserInterface.Controls.Control)">
            <summary>Sets up the parentage on the specified item</summary>
            <param name="item">Item to be parented</param>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ParentingControlCollection.screen">
            <summary>GUI this control is currently assigned to. Can be null.</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Controls.ParentingControlCollection.parent">
            <summary>Parent control to assign to all controls in this collection.</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.ParentingControlCollectionTest">
            <summary>Unit Test for the parenting control collection class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollectionTest.TestThrowOnSelfParentage">
            <summary>
              Tests whether the attempt to assign a node as its own parent is detected
              and causes an exception to be thrown.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollectionTest.TestThrowOnRingParentage">
            <summary>
              Tests whether the attempt to assign a node's parent as its child
              causes an exception to be thrown.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollectionTest.TestThrowOnMultipleParents">
            <summary>
              Tests whether the attempt to assign a node as child to more multiple
              parents causes an exception to be thrown.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollectionTest.TestParentAssignment">
            <summary>
              Tests whether a control is properly instated as the parent to
              any controls added to its children list.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollectionTest.TestClearing">
            <summary>
              Tests whether items are unparented when the collection is cleared
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollectionTest.TestItemReplacement">
            <summary>
              Tests whether the parent references are updated correctly if a control
              is replaced in the parent's children collection
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.ParentingControlCollectionTest.TestMoveToEnd">
            <summary>
              Verifies that the parenting control collection can move a child control to
              the end of the collection
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Controls.DesktopControlTest">
            <summary>Unit Test for the desktop control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Controls.DesktopControlTest.TestDefaultConstructor">
            <summary>
              Tests whether the default constructor of the desktop control is working
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.DuplicateNameException">
            <summary>The control's id has already been taken by another control</summary>
            <remarks>
              This exception indicates that you have a name collision between two controls
              in the same collection. It will either occur when you add a control to a
              collection that already contains a control with the same name, or when you
              change the name of a control to that of another control in the same collection.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.DuplicateNameException.#ctor">
            <summary>Initializes the exception</summary>
        </member>
        <member name="M:Nuclex.UserInterface.DuplicateNameException.#ctor(System.String)">
            <summary>Initializes the exception with an error message</summary>
            <param name="message">Error message describing the cause of the exception</param>
        </member>
        <member name="M:Nuclex.UserInterface.DuplicateNameException.#ctor(System.String,System.Exception)">
            <summary>Initializes the exception as a followup exception</summary>
            <param name="message">Error message describing the cause of the exception</param>
            <param name="inner">Preceding exception that has caused this exception</param>
        </member>
        <member name="M:Nuclex.UserInterface.DuplicateNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Initializes the exception from its serialized state</summary>
            <param name="info">Contains the serialized fields of the exception</param>
            <param name="context">Additional environmental informations</param>
        </member>
        <member name="T:Nuclex.UserInterface.DuplicateNameExceptionTest">
            <summary>Unit Test for the duplicate name exception</summary>
        </member>
        <member name="M:Nuclex.UserInterface.DuplicateNameExceptionTest.TestDefaultConstructor">
            <summary>
              Verifies that the exception's default constructor is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.DuplicateNameExceptionTest.TestInnerException">
            <summary>
              Checks whether the exception correctly stores its inner exception
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.DuplicateNameExceptionTest.TestSerialization">
            <summary>
              Test whether the exception can be serialized
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.GuiManager">
            <summary>Manages the state of the user interfaces and renders it</summary>
        </member>
        <member name="T:Nuclex.UserInterface.IGuiService">
            <summary>Game-wide interface for the GUI manager component</summary>
        </member>
        <member name="P:Nuclex.UserInterface.IGuiService.Screen">
            <summary>GUI that is being rendered</summary>
            <remarks>
              The GUI manager renders one GUI full-screen onto the primary render target
              (the backbuffer). This property holds the GUI that is being managed by
              the GUI manager component. You can replace it at any time, for example,
              if the player opens or closes your ingame menu.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.IGuiService.Visualizer">
            <summary>
              Responsible for creating a visual representation of the GUI on the screen
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.#ctor(Microsoft.Xna.Framework.GameServiceContainer)">
            <summary>
              Initializes a new GUI manager using the XNA service container
            </summary>
            <param name="gameServices">
              Game service container the GuiManager will register itself in and
              to take the services it consumes from.
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.#ctor(Microsoft.Xna.Framework.Graphics.IGraphicsDeviceService,Nuclex.Input.IInputService)">
            <summary>
              Initializes a new GUI manager without using the XNA service container
            </summary>
            <param name="graphicsDeviceService">
              Graphics device service the GUI will be rendered with
            </param>
            <param name="inputService">
              Input service used to read data from the input devices
            </param>
            <remarks>
              This constructor is provided for users of dependency injection frameworks.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.#ctor(Microsoft.Xna.Framework.GameServiceContainer,Microsoft.Xna.Framework.Graphics.IGraphicsDeviceService,Nuclex.Input.IInputService)">
            <summary>Initializes a new GUI manager using explicit services</summary>
            <param name="gameServices">
              Game service container the GuiManager will register itself in
            </param>
            <param name="graphicsDeviceService">
              Graphics device service the GUI will be rendered with
            </param>
            <param name="inputService">
              Input service used to read data from the input devices
            </param>
            <remarks>
              This constructor is provided for users of dependency injection frameworks
              or if you just want to be more explicit in stating which manager consumes
              what services.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.Dispose">
            <summary>Immediately releases all resources used the GUI manager</summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.Initialize">
            <summary>Handles second-stage initialization of the GUI manager</summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>Called when the component needs to update its state.</summary>
            <param name="gameTime">Provides a snapshot of the Game's timing values</param>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.Draw(Microsoft.Xna.Framework.GameTime)">
            <summary>Called when the drawable component needs to draw itself.</summary>
            <param name="gameTime">Provides a snapshot of the game's timing values</param>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.OnUpdateOrderChanged">
            <summary>Fires the UpdateOrderChanged event</summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.OnDrawOrderChanged">
            <summary>Fires the DrawOrderChanged event</summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.OnVisibleChanged">
            <summary>Fires the VisibleChanged event</summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.getInputService(System.IServiceProvider)">
            <summary>Retrieves the input service from a service provider</summary>
            <param name="serviceProvider">
              Service provider the input service is retrieved from
            </param>
            <returns>The retrieved input service</returns>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManager.getGraphicsDeviceService(System.IServiceProvider)">
            <summary>Retrieves the graphics device service from a service provider</summary>
            <param name="serviceProvider">
              Service provider the graphics device service is retrieved from
            </param>
            <returns>The retrieved graphics device service</returns>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.gameServices">
            <summary>Game service container the GUI has registered itself in</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.graphicsDeviceService">
            <summary>Graphics device servide the GUI uses</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.inputService">
            <summary>Input service the GUI uses</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.updateOrder">
            <summary>Update order rank relative to other game components</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.drawOrder">
            <summary>Draw order rank relative to other game components</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.visible">
            <summary>Whether the GUI should be drawn by Game.Draw()</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.inputCapturer">
            <summary>Captures user input for the XNA game</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.updateableInputCapturer">
            <summary>
              The IInputCapturer under its IUpdateable interface, if implemented
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.guiVisualizer">
            <summary>Draws the GUI</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.updateableGuiVisualizer">
            <summary>
              The IGuiVisualizer under its IUpdateable interface, if implemented
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManager.screen">
            <summary>The GUI screen representing the desktop</summary>
        </member>
        <member name="E:Nuclex.UserInterface.GuiManager.DrawOrderChanged">
            <summary>Fired when the DrawOrder property changes</summary>
        </member>
        <member name="E:Nuclex.UserInterface.GuiManager.VisibleChanged">
            <summary>Fired when the Visible property changes</summary>
        </member>
        <member name="E:Nuclex.UserInterface.GuiManager.UpdateOrderChanged">
            <summary>Fired when the UpdateOrder property changes</summary>
        </member>
        <member name="E:Nuclex.UserInterface.GuiManager.Microsoft#Xna#Framework#IUpdateable#EnabledChanged">
            <summary>Fired when the enabled property changes, which is never</summary>
        </member>
        <member name="P:Nuclex.UserInterface.GuiManager.Screen">
            <summary>GUI that is being rendered</summary>
            <remarks>
              The GUI manager renders one GUI full-screen onto the primary render target
              (the backbuffer). This property holds the GUI that is being managed by
              the GUI manager component. You can replace it at any time, for example,
              if the player opens or closes your ingame menu.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.GuiManager.InputCapturer">
            <summary>Input capturer that collects data from the input devices</summary>
            <remarks>
              The GuiManager will dispose its input capturer together with itself. If you
              want to keep the input capturer, unset it before disposing the GuiManager.
              If you want to replace the GuiManager's input capturer after it has constructed
              the default one, you should dispose the GuiManager's default input capturer
              after assigning your own.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.GuiManager.Visualizer">
            <summary>Visualizer that draws the GUI onto the screen</summary>
            <remarks>
              The GuiManager will dispose its visualizer together with itself. If you want
              to keep the visualizer, unset it before disposing the GuiManager. If you want
              to replace the GuiManager's visualizer after it has constructed the default
              one, you should dispose the GuiManager's default visualizer after assigning
              your own.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.GuiManager.UpdateOrder">
            <summary>
              Indicates when the game component should be updated relative to other game
              components. Lower values are updated first.
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.GuiManager.DrawOrder">
            <summary>
              The order in which to draw this object relative to other objects. Objects
              with a lower value are drawn first.
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.GuiManager.Visible">
            <summary>Whether the GUI should be drawn during Game.Draw()</summary>
        </member>
        <member name="P:Nuclex.UserInterface.GuiManager.Microsoft#Xna#Framework#IUpdateable#Enabled">
            <summary>Whether the component should be updated during Game.Update()</summary>
        </member>
        <member name="T:Nuclex.UserInterface.GuiManagerTest">
            <summary>Unit Test for the GUI manager</summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestStandardConstructor">
            <summary>
              Verifies that an the GUI manager's standard constructor is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestExplicitConstructor">
            <summary>
              Verifies that an the GUI manager's explicit constructor is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestCompatibilityConstructor">
            <summary>
              Verifies that an the GUI manager's compatibility constructor is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestInitialization">
            <summary>Verifies that the GUI manager can be initialized</summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestAssignScreenBeforeInitialize">
            <summary>
              Verifies that the screen can be assigned to the GUI manager before it
              has been initialized.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestAssignScreenAfterInitialize">
            <summary>
              Verifies that the screen can be assigned to the GUI manager after it
              has been initialized.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestVisualizerUpdate">
            <summary>
              Verifies that the Update() method is forwarded to the visualizer to allow
              for animated GUIs
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestDrawingWithoutScreen">
            <summary>
              Verifies that the Draw() method works even when no screen is assigned
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestDrawing">
            <summary>
              Verifies that the Draw() method is forwarded to the visualizer
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.TestVisualizerAssignment">
            <summary>
              Verifies that the GUI manager's visualizer can be retrieved and replaced
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.tryDispose``1(``0)">
            <summary>Tries to dispose an object that might implement IDisposable</summary>
            <typeparam name="PotentiallyDisposableType">
              Type which might implement IDisposable
            </typeparam>
            <param name="instance">
              Instance that will be disposed if it implement IDisposable
            </param>
            <returns>True if the instance implemented IDisposable and was disposed</returns>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManagerTest.mockedGraphicsDeviceService">
            <summary>Mocked graphics device service used in the tests</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManagerTest.mockedInputService">
            <summary>Mocked input manager used in the tests</summary>
        </member>
        <member name="T:Nuclex.UserInterface.GuiManagerTest.DummyVisualizer">
            <summary>Dummy GUI visualizer for unit testing</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.IGuiVisualizer">
            <summary>Interface for an exchangeable GUI painter</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.IGuiVisualizer.Draw(Nuclex.UserInterface.Screen)">
            <summary>Renders an entire control tree starting at the provided control</summary>
            <param name="screen">Screen containing the GUI that will be drawn</param>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.DummyVisualizer.Draw(Nuclex.UserInterface.Screen)">
            <summary>Renders an entire control tree starting at the provided control</summary>
            <param name="screen">Screen containing the GUI that will be drawn</param>
        </member>
        <member name="M:Nuclex.UserInterface.GuiManagerTest.DummyVisualizer.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>Called when the game component should be updated</summary>
            <param name="gameTime">Snapshot of the game's timing state</param>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManagerTest.DummyVisualizer.DrawCallCount">
            <summary>Number of times the Draw() method has been called</summary>
        </member>
        <member name="F:Nuclex.UserInterface.GuiManagerTest.DummyVisualizer.UpdateCallCount">
            <summary>Number of times the Update() method has been called</summary>
        </member>
        <member name="E:Nuclex.UserInterface.GuiManagerTest.DummyVisualizer.EnabledChanged">
            <summary>Raised when the Enabled property changes</summary>
        </member>
        <member name="E:Nuclex.UserInterface.GuiManagerTest.DummyVisualizer.UpdateOrderChanged">
            <summary>Raised when the UpdateOrder property changes</summary>
        </member>
        <member name="P:Nuclex.UserInterface.GuiManagerTest.DummyVisualizer.Microsoft#Xna#Framework#IUpdateable#Enabled">
            <summary>
              Whether the game component's Update() method should be called in Game.Update()
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.GuiManagerTest.DummyVisualizer.Microsoft#Xna#Framework#IUpdateable#UpdateOrder">
            <summary>
              When the game component should be updated relative to other game components.
              Lower values are updated first.
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Input.Command">
            <summary>Input commands that can be sent to a control</summary>
            <remarks>
              <para>
                The Nuclex GUI library is designed to work even when none of the usual
                input devices are available. In this case, the entire GUI is controlled
                through command keys, which might for example directly be linked to
                the buttons of a gamepad.
              </para>
              <para>
                It is, of course, still the responsibility of the developer to design
                GUIs in a simple and easy to navigate style. When building GUIs that
                are intended be used without a mouse, it is best not to use complex
                controls like lists or text input boxes.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.UserInterface.Input.Command.Accept">
            <summary>Accept the current selection (Ok button, Enter key)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.Command.Cancel">
            <summary>Cancel the current selection (Cancel button, Escape key)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.Command.SelectNext">
            <summary>Advance focus to the next control (Tab key)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.Command.SelectPrevious">
            <summary>Advance focus to the previous control (Shift+Tab key)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.Command.Up">
            <summary>Go up or focus control above (Cursor Up key)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.Command.Down">
            <summary>Go down or focus control below (Cursor Down key)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.Command.Left">
            <summary>Go left or focus control left (Cursor Left key)</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.Command.Right">
            <summary>Go right or focus control right (Cursor Right key)</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Input.DefaultInputCapturer">
            <summary>Default implementation of an input capturer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Input.IInputCapturer">
            <summary>
              Interface for input capturers that monitor user input and forward it to
              a freely settable input receiver
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.Input.IInputCapturer.InputReceiver">
            <summary>Input receiver any captured input will be sent to</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.#ctor(System.IServiceProvider)">
            <summary>
              Initializes a new input capturer, taking the input service from a service provider
            </summary>
            <param name="serviceProvider">
              Service provider the input capturer will take the input service from
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.#ctor(Nuclex.Input.IInputService)">
            <summary>
              Initializes a new input capturer using the specified input service
            </summary>
            <param name="inputService">
              Input service the capturer will subscribe to
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.ChangePlayerIndex(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Changes the controller which can interact with the GUI</summary>
            <param name="playerIndex">
              Index of the player whose controller will be allowed to interact with the GUI
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.ChangePlayerIndex(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Changes the controller which can interact with the GUI</summary>
            <param name="playerIndex">
              Index of the player whose controller will be allowed to interact with the GUI
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.subscribeInputDevices">
            <summary>Subscribes to the events of all input devices</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.subscribePlayerSpecificDevices">
            <summary>Subscribes to the events of all player-specific input devices</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.unsubscribeInputDevices">
            <summary>Unsubscribes from the events of all input devices</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.unsubscribePlayerSpecificInputDevices">
            <summary>Unsubscribes from the events of all player-specific input devices</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.buttonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad has been released</summary>
            <param name="buttons">Button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.buttonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad has been pressed</summary>
            <param name="buttons">Button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.mouseWheelRotated(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks the wheel was rotated</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.mouseMoved(System.Single,System.Single)">
            <summary>Called when the mouse cursor has been moved</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.mouseButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released</summary>
            <param name="buttons">Mouse button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.mouseButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed</summary>
            <param name="buttons">Mouse button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.characterEntered(System.Char)">
            <summary>Called when a character has been entered on the keyboard</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.keyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been released</summary>
            <param name="key">Key that was released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.keyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been pressed</summary>
            <param name="key">Key that was pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.getInputService(System.IServiceProvider)">
            <summary>Retrieves the input service from a service provider</summary>
            <param name="serviceProvider">
              Service provider the service is taken from
            </param>
            <returns>The input service stored in the service provider</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.playerIndex">
            <summary>Player index this input capturer is working with</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.inputReceiver">
            <summary>Current receiver of input events</summary>
            <remarks>
              Always valid. If no input receiver is assigned, this field will be set
              to a dummy receiver.
            </remarks>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.inputService">
            <summary>Input service the capturer is currently subscribed to</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.subscribedKeyboard">
            <summary>Keyboard the input capturer is subscribed to</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.subscribedMouse">
            <summary>Mouse the input capturer is subscribed to</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.subscribedGamePad">
            <summary>Game pad the input capturer is subscribed to</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.subscribedChatPad">
            <summary>Chat pad the input capturer is subscribed to</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.keyPressedDelegate">
            <summary>Delegate for the keyPressed() method</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.keyReleasedDelegate">
            <summary>Delegate for the keyReleased() method</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.characterEnteredDelegate">
            <summary>Delegate for the characterEntered() method</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.mouseButtonPressedDelegate">
            <summary>Delegate for the mouseButtonPressed() method</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.mouseButtonReleasedDelegate">
            <summary>Delegate for the mouseButtonReleased() method</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.mouseMovedDelegate">
            <summary>Delegate for the mouseMoved() method</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.mouseWheelRotatedDelegate">
            <summary>Delegate for the mouseWheelRotated() method</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.buttonPressedDelegate">
            <summary>Delegate for the buttonPressed() method</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.buttonReleasedDelegate">
            <summary>Delegate for the buttonReleased() method</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Input.DefaultInputCapturer.InputReceiver">
            <summary>Input receiver any captured input will be sent to</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver">
            <summary>Dummy receiver for input events</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Input.IInputReceiver">
            <summary>Interface for classes that can process user input</summary>
            <remarks>
              This interface is implemented by any class that can process user input.
              Normally, user input is directly fed into the <see cref="T:Nuclex.UserInterface.Screen"/> class
              which manages the global state of an isolated GUI system. It is also possible,
              though not recommended, to use this interface for sending input directly
              to a control, for example, to simulate text input for an input box.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectCommand(Nuclex.UserInterface.Input.Command)">
            <summary>Injects an input command into the input receiver</summary>
            <param name="command">Input command to be injected</param>
            <remarks>
              <para>
                If the GUI is run without the usual GUI input methods (eg. when a GUI is
                displayed on a gaming console), this is the sole way to feed input to
                the controls.
              </para>
              <para>
                By default, normal key presses will generate a command in addition to the
                KeyPress itself, so unless a control does something very special, it
                should respond to this method only and leave the KeyPress method alone ;)
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectButtonPress(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been pressed</summary>
            <param name="button">Button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectButtonRelease(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been released</summary>
            <param name="button">Button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectMouseMove(System.Single,System.Single)">
            <summary>Injects a mouse position update into the receiver</summary>
            <param name="x">New X coordinate of the mouse cursor on the screen</param>
            <param name="y">New Y coordinate of the mouse cursor on the screen</param>
            <remarks>
              When the mouse leaves the valid region (eg. if the game runs in windowed mode
              and the mouse cursor is moved outside of the window), a final mouse move
              notification is generated with the coordinates -1, -1
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectMousePress(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectMouseRelease(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectMouseWheel(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks that the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectKeyPress(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
            <remarks>
              Only handle this if you need it for some special purpose. For standard commands
              like confirmation and cancellation, simply respond to InjectCommand()
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectKeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released again</summary>
            <param name="keyCode">Code of the key that was released</param>
            <remarks>
              Only handle this if you need it for some special purpose. For standard commands
              like confirmation and cancellation, simply respond to InjectCommand()
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Input.IInputReceiver.InjectCharacter(System.Char)">
            <summary>Handle user text input by a physical or virtual keyboard</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="F:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.Default">
            <summary>Default instance of the dummy receiver</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectCommand(Nuclex.UserInterface.Input.Command)">
            <summary>Injects an input command into the input receiver</summary>
            <param name="command">Input command to be injected</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectButtonPress(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been pressed</summary>
            <param name="button">Button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectButtonRelease(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been released</summary>
            <param name="button">Button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectMouseMove(System.Single,System.Single)">
            <summary>Injects a mouse position update into the receiver</summary>
            <param name="x">New X coordinate of the mouse cursor on the screen</param>
            <param name="y">New Y coordinate of the mouse cursor on the screen</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectMousePress(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectMouseRelease(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectMouseWheel(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks that the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectKeyPress(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectKeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released again</summary>
            <param name="keyCode">Code of the key that was released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Input.DefaultInputCapturer.DummyInputReceiver.InjectCharacter(System.Char)">
            <summary>Handle user text input by a physical or virtual keyboard</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="T:Nuclex.UserInterface.Input.DefaultInputCapturerTest">
            <summary>Unit Test for the default input capturer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.RectangleF">
            <summary>Two-dimensional rectangle using floating point coordinates</summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>Initializes a floating point rectangle</summary>
            <param name="x">The x-coordinate of the rectangle's lower right corner</param>
            <param name="y">The y-coordinate of the rectangle's lower right corner</param>
            <param name="width">Width of the rectangle</param>
            <param name="height">Height of the rectangle</param>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Offset(Microsoft.Xna.Framework.Vector2)">
            <summary>Changes the position of the Rectangle</summary>
            <param name="amount">The values to adjust the position of the rectangle by</param>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Offset(System.Single,System.Single)">
            <summary>Changes the position of the Rectangle</summary>
            <param name="offsetX">Change in the x-position</param>
            <param name="offsetY">Change in the y-position</param>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Inflate(System.Single,System.Single)">
            <summary>
              Pushes the edges of the Rectangle out by the horizontal and
              vertical values specified
            </summary>
            <param name="horizontalAmount">Value to push the sides out by</param>
            <param name="verticalAmount">Value to push the top and bottom out by</param>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Contains(Microsoft.Xna.Framework.Vector2)">
            <summary>Determines whether the rectangle contains a specified Point</summary>
            <param name="point">The point to evaluate</param>
            <returns>
              True if the specified point is contained within this rectangle; false otherwise
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Contains(Microsoft.Xna.Framework.Vector2@,System.Boolean@)">
            <summary>Determines whether the rectangle contains a specified Point</summary>
            <param name="point">The point to evaluate</param>
            <param name="result">
              True if the specified point is contained within this rectangle; false otherwise
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Contains(System.Single,System.Single)">
            <summary>
              Determines whether this Rectangle contains a specified point represented by
              its x- and y-coordinates
            </summary>
            <param name="x">The x-coordinate of the specified point</param>
            <param name="y">The y-coordinate of the specified point</param>
            <returns>
              True if the specified point is contained within this rectangle; false otherwise
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Contains(Nuclex.UserInterface.RectangleF)">
            <summary>
              Determines whether the rectangle contains another rectangle in its entirety
            </summary>
            <param name="other">The rectangle to evaluate</param>
            <returns>
              True if the rectangle entirely contains the specified rectangle; false otherwise
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Contains(Nuclex.UserInterface.RectangleF@,System.Boolean@)">
            <summary>
              Determines whether this rectangle entirely contains a specified rectangle
            </summary>
            <param name="other">The rectangle to evaluate</param>
            <param name="result">
              On exit, is true if this rectangle entirely contains the specified rectangle,
              or false if not
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Intersects(Nuclex.UserInterface.RectangleF)">
            <summary>
              Determines whether a specified rectangle intersects with this rectangle
            </summary>
            <param name="rectangle">The rectangle to evaluate</param>
            <returns>
              True if the specified rectangle intersects with this one; false otherwise
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Intersects(Nuclex.UserInterface.RectangleF@,System.Boolean@)">
            <summary>
              Determines whether a specified rectangle intersects with this rectangle
            </summary>
            <param name="rectangle">The rectangle to evaluate</param>
            <param name="result">
              True if the specified rectangle intersects with this one; false otherwise
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Equals(Nuclex.UserInterface.RectangleF)">
            <summary>
              Determines whether the specified rectangle is equal to this rectangle
            </summary>
            <param name="other">The rectangle to compare with this rectangle</param>
            <returns>
              True if the specified rectangle is equal to the this rectangle; false otherwise
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.Equals(System.Object)">
            <summary>
              Returns a value that indicates whether the current instance is equal to a
              specified object
            </summary>
            <param name="other">Object to make the comparison with</param>
            <returns>
              True if the current instance is equal to the specified object; false otherwise
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.ToString">
            <summary>Retrieves a string representation of the current object</summary>
            <returns>String that represents the object</returns>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.GetHashCode">
            <summary>Gets the hash code for this object</summary>
            <returns>Hash code for this object</returns>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.op_Equality(Nuclex.UserInterface.RectangleF,Nuclex.UserInterface.RectangleF)">
            <summary>Compares two rectangles for equality</summary>
            <param name="first">Source rectangle</param>
            <param name="second">Source rectangle</param>
            <returns>True if the rectangles are equal; false otherwise</returns>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleF.op_Inequality(Nuclex.UserInterface.RectangleF,Nuclex.UserInterface.RectangleF)">
            <summary>Compares two rectangles for inequality</summary>
            <param name="first">Source rectangle</param>
            <param name="second">Source rectangle</param>
            <returns>True if the rectangles are not equal; false otherwise</returns>
        </member>
        <member name="F:Nuclex.UserInterface.RectangleF.X">
            <summary>Specifies the x-coordinate of the rectangle</summary>
        </member>
        <member name="F:Nuclex.UserInterface.RectangleF.Y">
            <summary>Specifies the y-coordinate of the rectangle</summary>
        </member>
        <member name="F:Nuclex.UserInterface.RectangleF.Width">
            <summary>Specifies the width of the rectangle</summary>
        </member>
        <member name="F:Nuclex.UserInterface.RectangleF.Height">
            <summary>Specifies the height of the rectangle</summary>
        </member>
        <member name="F:Nuclex.UserInterface.RectangleF.empty">
            <summary>An empty rectangle</summary>
        </member>
        <member name="P:Nuclex.UserInterface.RectangleF.Left">
            <summary>Returns the x-coordinate of the left side of the rectangle</summary>
            <returns>The x-coordinate of the left side of the rectangle</returns>
        </member>
        <member name="P:Nuclex.UserInterface.RectangleF.Right">
            <summary>Returns the x-coordinate of the right side of the rectangle</summary>
            <returns>The x-coordinate of the right side of the rectangle</returns>
        </member>
        <member name="P:Nuclex.UserInterface.RectangleF.Top">
            <summary>Returns the y-coordinate of the top of the rectangle</summary>
            <returns>The y-coordinate of the top of the rectangle</returns>
        </member>
        <member name="P:Nuclex.UserInterface.RectangleF.Bottom">
            <summary>Returns the y-coordinate of the bottom of the rectangle</summary>
            <returns>The y-coordinate of the bottom of the rectangle</returns>
        </member>
        <member name="P:Nuclex.UserInterface.RectangleF.Empty">
            <summary>Returns a Rectangle with all of its values set to zero</summary>
            <returns>An empty Rectangle</returns>
        </member>
        <member name="T:Nuclex.UserInterface.RectangleFTest">
            <summary>Unit Test for the floating point rectangle class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestEmptyRectangle">
            <summary>
              Validates the empty rectangle provided by the floating point rectangle
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestConstructor">
            <summary>
              Verifies that the constructor of the floating point rectangle is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestOffset">
            <summary>
              Verifies that the Offset() method is working as expected
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestInflate">
            <summary>
              Verifies that the Inflate() method is working as expected
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestContainsWithPoint">
            <summary>
              Verifies that the Contains() method is working as expected for points
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestContainsWithPointReference">
            <summary>
              Verifies that the Contains() method is working as expected for point references
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestContainsWithRectangle">
            <summary>
              Verifies that the Contains() method is working as expected for rectangles
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestContainsWithRectangleReference">
            <summary>
              Verifies that the Contains() method is working as expected for rectangle references
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestIntersectsWithRectangle">
            <summary>
              Verifies that the Intersects() method is working as expected for rectangles
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestIntersectsWithRectangleReference">
            <summary>
              Verifies that the Intersects() method is working as expected for rectangles
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestEqualityOperator">
            <summary>
              Verifies that the equality operator of the unified rectangle is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestInequalityOperator">
            <summary>
              Verifies that the inequality operator of the unified rectangle is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestEqualsWithDowncast">
            <summary>
              Tests the Equals() method of the unified rectangle class when it has to perform
              a downcast to obtain the comparison rectangle
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestEqualsWithDifferentType">
            <summary>
              Tests the Equals() method of the unified rectangle class against a different type
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestEqualsWithNullReference">
            <summary>
              Tests the Equals() method of the unified rectangle class against a null pointer
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestGetHashCode">
            <summary>
              Tests the GetHashCode() method of the unified rectangle class
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.RectangleFTest.TestToString">
            <summary>
              Tests the ToString() method of the unified rectangle class
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.UniAssertHelper">
            <summary>Contains special assertions for floating numbers</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelper.AreAlmostEqual(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar,System.Int32)">
            <summary>Ensures that two unified scalars are nearly equal to each other</summary>
            <param name="expected">Expected unified scalar value</param>
            <param name="actual">Actual unified scalar value</param>
            <param name="deltaUlps">
              Allowed deviation in representable floating point values for each of the
              unified scalar's fields
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelper.AreAlmostEqual(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniVector,System.Int32)">
            <summary>Ensures that two unified vectors are nearly equal to each other</summary>
            <param name="expected">Expected unified vector</param>
            <param name="actual">Actual unified vector</param>
            <param name="deltaUlps">
              Allowed deviation in representable floating point values for each of the
              unified vector's fields
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelper.AreAlmostEqual(Nuclex.UserInterface.UniRectangle,Nuclex.UserInterface.UniRectangle,System.Int32)">
            <summary>Ensures that two unified vectors are nearly equal to each other</summary>
            <param name="expected">Expected unified vector</param>
            <param name="actual">Actual unified vector</param>
            <param name="deltaUlps">
              Allowed deviation in representable floating point values for each of the
              unified vector's fields
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelper.areAlmostEqual(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar,System.Int32)">
            <summary>Determines whether two unified scalar values are nearly equal</summary>
            <param name="left">Unified scalar value to compare on the left side</param>
            <param name="right">Unified scalar value to compare on the right side</param>
            <param name="deltaUlps">
              Allowed deviation in representable floating point values for each of the
              unified vector's fields
            </param>
            <returns>True if the provided unified scalar values are nearly equal</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelper.areAlmostEqual(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniVector,System.Int32)">
            <summary>Determines whether two unified vectors are nearly equal</summary>
            <param name="left">Unified vector to compare on the left side</param>
            <param name="right">Unified vector to compare on the right side</param>
            <param name="deltaUlps">
              Allowed deviation in representable floating point values for each of the
              unified vector's fields
            </param>
            <returns>True if the provided unified vectors are nearly equal</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelper.areAlmostEqual(Nuclex.UserInterface.UniRectangle,Nuclex.UserInterface.UniRectangle,System.Int32)">
            <summary>Determines whether two unified rectangles are nearly equal</summary>
            <param name="left">Unified rectangle to compare on the left side</param>
            <param name="right">Unified rectangle to compare on the right side</param>
            <param name="deltaUlps">
              Allowed deviation in representable floating point values for each of the
              unified vector's fields
            </param>
            <returns>True if the provided unified rectangles are nearly equal</returns>
        </member>
        <member name="T:Nuclex.UserInterface.UniAssertHelperTest">
            <summary>Unit Test for the unified value assertion helper class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.TestAlmostEqualScalars">
            <summary>
              Validates that a deviation within the allowed tolerance is accepted as being equal
              for a unified scalar value
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.TestThrowOnAlmostEqualScalarsWithTooHighFraction">
            <summary>
              Validates that a deviation of the fraction field outside of the tolerance results
              in the assertion failing
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.TestThrowOnAlmostEqualScalarsWithTooLowOffset">
            <summary>
              Validates that a deviation of the offset field outside of the tolerance results
              in the assertion failing
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.TestAlmostEqualVectors">
            <summary>
              Validates that a deviation within the allowed tolerance is accepted as being equal
              for a unified vector
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.TestThrowOnAlmostEqualVectorsWithXDifference">
            <summary>
              Validates that a deviation of the X field outside of the tolerance results
              in the assertion failing
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.TestThrowOnAlmostEqualVectorsWithYDifference">
            <summary>
              Validates that a deviation of the Y field outside of the tolerance results
              in the assertion failing
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.TestAlmostEqualRectangles">
            <summary>
              Validates that a deviation within the allowed tolerance is accepted as being equal
              for a unified rectangle
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.TestThrowOnAlmostEqualVectorsWithLocationDifference">
            <summary>
              Validates that a deviation of the Location field outside of the tolerance results
              in the assertion failing
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.TestThrowOnAlmostEqualVectorsWithSizeDifference">
            <summary>
              Validates that a deviation of the Size field outside of the tolerance results
              in the assertion failing
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniAssertHelperTest.adjust(System.Single,System.Int32)">
            <summary>
              Adjusts a floating point value by the specified amount of neighbouring
              representable values
            </summary>
            <param name="value">Floating point value to be adjusted</param>
            <param name="ulps">Numbers of neighbouring representable values to step</param>
            <returns>The adjusted floating point value</returns>
        </member>
        <member name="F:Nuclex.UserInterface.UniAssertHelperTest.exactFloat">
            <summary>The exact test value as a float</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniAssertHelperTest.minusTwoFloat">
            <summary>The second next possible smaller float from the test value</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniAssertHelperTest.minusOneFloat">
            <summary>The next possible smaller float from the test value</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniAssertHelperTest.plusOneFloat">
            <summary>The next possible greater float from the test value</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniAssertHelperTest.plusTwoFloat">
            <summary>The second next possible greater float from the test value</summary>
        </member>
        <member name="T:Nuclex.UserInterface.UniRectangle">
            <summary>
              Two-dimensional rectangle of combined fraction and offset coordinates
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniRectangle.Empty">
            <summary>An empty unified rectangle</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.#ctor(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniVector)">
            <summary>Initializes a new rectangle from a location and a size</summary>
            <param name="location">Location of the rectangle's upper left corner</param>
            <param name="size">Size of the area covered by the rectangle</param>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.#ctor(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar)">
            <summary>
              Initializes a new rectangle from the provided individual coordinates
            </summary>
            <param name="x">X coordinate of the rectangle's left border</param>
            <param name="y">Y coordinate of the rectangle's upper border</param>
            <param name="width">Width of the area covered by the rectangle</param>
            <param name="height">Height of the area covered by the rectangle</param>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.ToOffset(Microsoft.Xna.Framework.Vector2)">
            <summary>Converts the rectangle into pure offset coordinates</summary>
            <param name="containerSize">
              Dimensions of the container the fractional part of the rectangle count for
            </param>
            <returns>A rectangle with the pure offset coordinates of the rectangle</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.ToOffset(System.Single,System.Single)">
            <summary>Converts the rectangle into pure offset coordinates</summary>
            <param name="containerWidth">
              Width of the container the fractional part of the rectangle counts for
            </param>
            <param name="containerHeight">
              Height of the container the fractional part of the rectangle counts for
            </param>
            <returns>A rectangle with the pure offset coordinates of the rectangle</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.op_Inequality(Nuclex.UserInterface.UniRectangle,Nuclex.UserInterface.UniRectangle)">
            <summary>Checks two rectangles for inequality</summary>
            <param name="first">First rectangle to be compared</param>
            <param name="second">Second rectangle to be compared</param>
            <returns>True if the instances differ or exactly one reference is set to null</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.op_Equality(Nuclex.UserInterface.UniRectangle,Nuclex.UserInterface.UniRectangle)">
            <summary>Checks two rectangles for equality</summary>
            <param name="first">First rectangle to be compared</param>
            <param name="second">Second rectangle to be compared</param>
            <returns>True if both instances are equal or both references are null</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.Equals(System.Object)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.Equals(Nuclex.UserInterface.UniRectangle)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.GetHashCode">
            <summary>Obtains a hash code of this instance</summary>
            <returns>The hash code of the instance</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangle.ToString">
            <summary>
              Returns a human-readable string representation for the unified rectangle
            </summary>
            <returns>The human-readable string representation of the unified rectangle</returns>
        </member>
        <member name="F:Nuclex.UserInterface.UniRectangle.Location">
            <summary>The location of the rectangle's upper left corner</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniRectangle.Size">
            <summary>The size of the rectangle</summary>
        </member>
        <member name="P:Nuclex.UserInterface.UniRectangle.Left">
            <summary>X coordinate of the rectangle's left border</summary>
        </member>
        <member name="P:Nuclex.UserInterface.UniRectangle.Top">
            <summary>Y coordinate of the rectangle's upper border</summary>
        </member>
        <member name="P:Nuclex.UserInterface.UniRectangle.Right">
            <summary>X coordinate of the rectangle's right border</summary>
        </member>
        <member name="P:Nuclex.UserInterface.UniRectangle.Bottom">
            <summary>Y coordinate of the rectangle's lower border</summary>
        </member>
        <member name="P:Nuclex.UserInterface.UniRectangle.Min">
            <summary>Point consisting of the lesser coordinates of the rectangle</summary>
        </member>
        <member name="P:Nuclex.UserInterface.UniRectangle.Max">
            <summary>Point consisting of the greater coordinates of the rectangle</summary>
        </member>
        <member name="T:Nuclex.UserInterface.UniRectangleTest">
            <summary>Unit Test for the unified rectangle class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestVectorConstructor">
            <summary>
              Verifies that the vector constructor of the unified rectangle class is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestScalarConstructor">
            <summary>
              Verifies that the scalar constructor of the unified rectangle class is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestToOffset">
            <summary>Verifies that the ToOffset() method works as expected</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestEqualityOperator">
            <summary>
              Verifies that the equality operator of the unified rectangle is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestInequalityOperator">
            <summary>
              Verifies that the inequality operator of the unified rectangle is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestEqualsWithDowncast">
            <summary>
              Tests the Equals() method of the unified rectangle class when it has to perform
              a downcast to obtain the comparison rectangle
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestEqualsWithDifferentType">
            <summary>
              Tests the Equals() method of the unified rectangle class against a different type
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestEqualsWithNullReference">
            <summary>
              Tests the Equals() method of the unified rectangle class against a null pointer
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestGetHashCode">
            <summary>
              Tests the GetHashCode() method of the unified rectangle class
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestToString">
            <summary>
              Tests the ToString() method of the unified rectangle class
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestLeftProperty">
            <summary>Verifies that the left property works as expected</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestRightProperty">
            <summary>Verifies that the right property works as expected</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestTopProperty">
            <summary>Verifies that the top property works as expected</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestBottomProperty">
            <summary>Verifies that the bottom property works as expected</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestMinProperty">
            <summary>Verifies that the min property works as expected</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniRectangleTest.TestMaxProperty">
            <summary>Verifies that the max property works as expected</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniRectangleTest.firstTestScalar">
            <summary>First value used for testing in the individual unit test methods</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniRectangleTest.secondTestScalar">
            <summary>Second value used for testing in the individual unit test methods</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniRectangleTest.thirdTestScalar">
            <summary>Third value used for testing in the individual unit test methods</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniRectangleTest.fourthTestScalar">
            <summary>Fourth value used for testing in the individual unit test methods</summary>
        </member>
        <member name="T:Nuclex.UserInterface.UniScalar">
            <summary>Stores a size or location on one axis</summary>
            <remarks>
              <para>
                Any position or size in Nuclex.UserInterface uses a combined position consisting
                of a fraction and an offset. The fraction specifies the position or size as a
                fraction of the parent frame's bounds and usually is in the range between 0.0 and
                1.0. The offset simply is the number of pixels to divert from the thusly
                determined location.
              </para>
              <para>
                Through the use of both fraction and offset, any kind of anchoring behavior can be
                achieved that normally would require a complex anchoring and docking system as can
                be seen in System.Windows.Forms.
              </para>
              <para>
                If you, for example, wanted to always place a control 20 pixels from the right
                border of its parent container, set the fraction of its position to 1.0 (always
                on the right border) and the offset to -20.0 (go 20 units to the left from there).
              </para>
              <para>
                You can achieve traditional absolute positioning by leaving the fraction at 0.0,
                which is equivalent to the upper or left border of the parent container.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.UserInterface.UniScalar.Zero">
            <summary>A scalar that has been initialized to zero</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.#ctor(System.Single)">
            <summary>Initializes a new scalar from an offset only</summary>
            <param name="offset">Offset in pixels this scalar indicates</param>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.#ctor(System.Single,System.Single)">
            <summary>Initializes a new dimension from an absolute and a relative part</summary>
            <param name="fraction">Fractional position within the parent frame</param>
            <param name="offset">Offset in pixels from the fractional position</param>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.op_Implicit(System.Single)~Nuclex.UserInterface.UniScalar">
            <summary>Implicitely constructs a scalar using a float as the absolute part</summary>
            <param name="offset">Float that will be used for the scalar's absolute value</param>
            <returns>
              A new scalar constructed with the original float as its absolute part
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.ToOffset(System.Single)">
            <summary>Converts the scalar into a pure offset position</summary>
            <param name="containerSize">
              Absolute dimension of the parent that the relative coordinate relates to
            </param>
            <returns>
              The absolute position in the parent container denoted by the dimension
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.op_Addition(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar)">
            <summary>Adds one scalar to another</summary>
            <param name="scalar">Base scalar to add to</param>
            <param name="summand">Scalar to add to the base</param>
            <returns>The result of the addition</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.op_Subtraction(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar)">
            <summary>Subtracts one scalar from another</summary>
            <param name="scalar">Base scalar to subtract from</param>
            <param name="subtrahend">Scalar to subtract from the base</param>
            <returns>The result of the subtraction</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.op_Division(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar)">
            <summary>Divides one scalar by another</summary>
            <param name="scalar">Base scalar to be divided</param>
            <param name="divisor">Divisor to divide by</param>
            <returns>The result of the division</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.op_Multiply(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar)">
            <summary>Multiplies one scalar with another</summary>
            <param name="scalar">Base scalar to be multiplied</param>
            <param name="factor">Factor to multiply by</param>
            <returns>The result of the multiplication</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.op_Inequality(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar)">
            <summary>Checks two scalars for inequality</summary>
            <param name="first">First scalar to be compared</param>
            <param name="second">Second scalar to be compared</param>
            <returns>True if the instances differ or exactly one reference is set to null</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.op_Equality(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar)">
            <summary>Checks two scalars for equality</summary>
            <param name="first">First scalar to be compared</param>
            <param name="second">Second scalar to be compared</param>
            <returns>True if both instances are equal or both references are null</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.Equals(System.Object)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.Equals(Nuclex.UserInterface.UniScalar)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.GetHashCode">
            <summary>Obtains a hash code of this instance</summary>
            <returns>The hash code of the instance</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalar.ToString">
            <summary>
              Returns a human-readable string representation for the unified scalar
            </summary>
            <returns>The human-readable string representation of the unified scalar</returns>
        </member>
        <member name="F:Nuclex.UserInterface.UniScalar.Fraction">
            <summary>Position of the scalar as fraction of the parent frame's bounds</summary>
            <remarks>
              The relative part is normally in the 0.0 .. 1.0 range, denoting the
              fraction of the parent container's size the scalar will indicate.
            </remarks>
        </member>
        <member name="F:Nuclex.UserInterface.UniScalar.Offset">
            <summary>Offset of the scalar in pixels relative to its fractional position</summary>
            <remarks>
              This part is taken literally without paying attention to the size of
              the parent container the coordinate is used in.
            </remarks>
        </member>
        <member name="T:Nuclex.UserInterface.Screen">
            <summary>Manages the controls and their state on a GUI screen</summary>
            <remarks>
              This class manages the global state of a distinct user interface. Unlike your
              typical GUI library, the Nuclex.UserInterface library can handle any number of
              simultaneously active user interfaces at the same time, making the library
              suitable for usage on virtual ingame computers and multi-client environments
              such as split-screen games or switchable graphical terminals.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.#ctor">
            <summary>Initializes a new GUI</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.#ctor(System.Single,System.Single)">
            <summary>Initializes a new GUI</summary>
            <param name="width">Width of the area the GUI can occupy</param>
            <param name="height">Height of the area the GUI can occupy</param>
            <remarks>
              Width and height should reflect the entire drawable area of your GUI. If you
              want to limit the region which the GUI is allowed to use (eg. to only use the
              safe area of a TV) please resize the desktop control accordingly!
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectCommand(Nuclex.UserInterface.Input.Command)">
            <summary>Injects a command into the processor</summary>
            <param name="command">Input command that will be injected</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectKeyPress(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectKeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released again</summary>
            <param name="keyCode">Code of the key that was released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectCharacter(System.Char)">
            <summary>Handle user text input by a physical or virtual keyboard</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectButtonPress(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been pressed</summary>
            <param name="button">Button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectButtonRelease(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the gamepad has been released</summary>
            <param name="button">Button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectMouseMove(System.Single,System.Single)">
            <summary>Injects a mouse position update into the GUI</summary>
            <param name="x">X coordinate of the mouse cursor within the screen</param>
            <param name="y">Y coordinate of the mouse cursor within the screen</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectMousePress(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectMouseRelease(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.InjectMouseWheel(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks that the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.onFocusChanged(Nuclex.UserInterface.Controls.Control)">
            <summary>Triggers the FocusChanged event</summary>
            <param name="focusedControl">Control that has gotten the input focus</param>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.getDirectionalDistance(Nuclex.UserInterface.RectangleF@,Nuclex.UserInterface.RectangleF@,Nuclex.UserInterface.Input.Command)">
            <summary>
              Determines the distance of one rectangle to the other, also taking direction
              into account
            </summary>
            <param name="ownBounds">Boundaries of the base rectangle</param>
            <param name="otherBounds">Boundaries of the other rectangle</param>
            <param name="direction">Direction into which distance will be determined</param>
            <returns>
              The direction of the other rectangle of NaN if it didn't lie in that direction
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Screen.canControlGetFocus(Nuclex.UserInterface.Controls.Control)">
            <summary>Determines whether a control can obtain the input focus</summary>
            <param name="control">Control that will be checked for focusability</param>
            <returns>True if the specified control can obtain the input focus</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Screen.maxKeyboardKey">
            <summary>Highest value in the Keys enumeration</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Screen.size">
            <summary>Size of the GUI area in world units or pixels</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Screen.desktopControl">
            <summary>Control responsible for hosting the GUI's top-level controls</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Screen.focusedControl">
            <summary>Child that currently has the input focus</summary>
            <remarks>
              If this field is non-null, all keyboard input sent to the Gui is handed
              over to the focused control. Otherwise, keyboard input is discarded.
            </remarks>
        </member>
        <member name="F:Nuclex.UserInterface.Screen.activatedControl">
            <summary>Control the user has activated through one of the input devices</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Screen.heldKeyCount">
            <summary>Number of keys being held down on the keyboard</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Screen.heldKeys">
            <summary>Keys on the keyboard the user is currently holding down</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Screen.heldButtons">
            <summary>Buttons on the game pad the user is currently holding down</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Screen.heldMouseButtons">
            <summary>Mouse buttons currently being held down</summary>
        </member>
        <member name="E:Nuclex.UserInterface.Screen.FocusChanged">
            <summary>Triggered when the control in focus changes</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Screen.Width">
            <summary>Width of the screen in pixels</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Screen.Height">
            <summary>Height of the screen in pixels</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Screen.Desktop">
            <summary>Control responsible for hosting the GUI's top-level controls</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Screen.IsInputCaptured">
            <summary>Whether the GUI has currently captured the input devices</summary>
            <remarks>
              <para>
                When you mix GUIs and gameplay (for example, in a strategy game where the GUI
                manages the build menu and the remainder of the screen belongs to the game),
                it is important to keep control of who currently owns the input devices.
              </para>
              <para>
                Assume the player is drawing a selection rectangle around some units using
                the mouse. He will press the mouse button outside any GUI elements, keep
                holding it down and possibly drag over the GUI. Until the player lets go
                of the mouse button, input exclusively belongs to the game. The same goes
                vice versa, of course.
              </para>
              <para>
                This property tells whether the GUI currently thinks that all input belongs
                to it. If it is true, the game should not process any input. The GUI will
                implement the input model as described here and respect the game's ownership
                of the input devices if a mouse button is pressed outside of the GUI. To
                correctly handle input device ownership, send all input to the GUI
                regardless of this property's value, then check this property and if it
                returns false let your game process the input.
              </para>
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.Screen.IsMouseOverGui">
            <summary>True if the mouse is currently hovering over any GUI elements</summary>
            <remarks>
              Useful if you mix gameplay with a GUI and use different mouse cursors
              depending on the location of the mouse. As long as input is not captured
              (see <see cref="P:Nuclex.UserInterface.Screen.IsInputCaptured"/>) you can use this property to know
              whether you should use the standard GUI mouse cursor or let your game
              decide which cursor to use.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.Screen.FocusedControl">
            <summary>Child control that currently has the input focus</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Screen.anyKeysOrButtonsPressed">
            <summary>
              Whether any keys, mouse buttons or game pad buttons are beind held pressed
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.ScreenTest">
            <summary>Unit Test for the Screen class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.Setup">
            <summary>Initialization routine executed before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestDefaultConstructor">
            <summary>Tests the default constructor of the screen class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestFullConstructor">
            <summary>Tests the full featured constructor of the screen class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestCommandProcessing">
            <summary>
              Verifies that an action input is processed by the screen
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestScreenPropagationOnInsertion">
            <summary>
              Tests whether the Gui reference is properly propagated to all controls
              and their children in a control tree.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestInjectButtonPress">
            <summary>
              Verifies that button presses are propagated down the control tree
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestButtonPressWithActivatedControl">
            <summary>
              Verifies that button press notifications are routed to the activated control
              instead of searching for a control to handle the press
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestButtonPressWithFocusedControl">
            <summary>
              Verifies that button press notifications are sent to the focused control
              first when looking the a control that handles the notification
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestInjectKeyPress">
            <summary>
              Verifies that key presses are propagated down the control tree
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestKeyPressWithActivatedControl">
            <summary>
              Verifies that key press notifications are routed to the activated control
              instead of searching for a control to handle the press
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestKeyPressWithFocusedControl">
            <summary>
              Verifies that key press notifications are sent to the focused control
              first when looking the a control that handles the notification
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestMousePressWithActivatedControl">
            <summary>
              Verifies that mouse pressed are routed to the activated control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestFocusChangeEvent">
            <summary>
              Verifies that the FocusChanged event is triggered when the control
              in focus changes
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestMouseWheel">
            <summary>
              Verifies that mouse wheel rotations are propagated down the control tree
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestMouseWheelWithActivatedControl">
            <summary>
              Verifies that mouse wheel rotations are sent to the activated control first
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestInjectCharacter">
            <summary>
              Verifies that entered characters are sent to the focused control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestFocusSwitching">
            <summary>Tests whether focus can be changed using the keyboard</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestFocusSwitchingWithUnfocusableControl">
            <summary>
              Verifies that the screen skips an unfocusable control and jumps to the
              next focusable control.
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestNoFocusChangeOnHandledDirectionalCommand">
            <summary>
              Verifies that if the focused control handles a directional command, no
              focus switching will occur
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestFocusSwitchingWithoutFocusedControl">
            <summary>
              Verifies that the screen can handle a focus switch request without any
              focused control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestFocusSwitchingWithDisconnectedControl">
            <summary>
              Verifies that the screen can handle a focus switch when the control
              currently assigned as the focused control has been disconnected from the tree
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestClassicFocusSwitching">
            <summary>
              Verifies that classic focus switching is still supported
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.TestAcceptAndCancelFromKeyboard">
            <summary>
              Verifies that classic focus switching is still supported
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.mockReceiver(Nuclex.UserInterface.Screen)">
            <summary>Mocks a receiver for the input processing of a control</summary>
            <param name="screen">Screen to mock an input receiver on</param>
            <returns>The mocked input receiver</returns>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.mockSubscriber(Nuclex.UserInterface.Screen)">
            <summary>Mocks a subscriber to the screen's events</summary>
            <param name="screen">Screen to mock an event subcriber to</param>
            <returns>The mocked event subscriber</returns>
        </member>
        <member name="F:Nuclex.UserInterface.ScreenTest.mockery">
            <summary>Mock object factory</summary>
        </member>
        <member name="T:Nuclex.UserInterface.ScreenTest.DelegatingControl">
            <summary>Control that delegates input to another input receiver</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.DelegatingControl.#ctor(Nuclex.UserInterface.Input.IInputReceiver)">
            <summary>Initializes a new input delegating control</summary>
            <param name="receiver">Receiver to which the input is delegated</param>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.DelegatingControl.OnCommand(Nuclex.UserInterface.Input.Command)">
            <summary>Called when a command was sent to the control</summary>
            <param name="command">Command the control should perform</param>
            <returns>Whether the command has been processed by the control</returns>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.DelegatingControl.OnMouseMoved(System.Single,System.Single)">
            <summary>Called when the mouse position is updated</summary>
            <param name="x">X coordinate of the mouse cursor on the GUI</param>
            <param name="y">Y coordinate of the mouse cursor on the GUI</param>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.DelegatingControl.OnMousePressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.DelegatingControl.OnMouseReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.DelegatingControl.OnMouseWheel(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks that the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.DelegatingControl.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.DelegatingControl.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released again</summary>
            <param name="keyCode">Code of the key that was released</param>
        </member>
        <member name="F:Nuclex.UserInterface.ScreenTest.DelegatingControl.receiver">
            <summary>Input receiver all received input is delegated to</summary>
        </member>
        <member name="T:Nuclex.UserInterface.ScreenTest.GamePadTestControl">
            <summary>Control used to test game pad notifications</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.GamePadTestControl.OnButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad has been pressed</summary>
            <param name="button">Button that has been pressed</param>
            <returns>
              True if the button press was handled by the control, otherwise false.
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.GamePadTestControl.OnButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad has been released</summary>
            <param name="button">Button that has been released</param>
        </member>
        <member name="F:Nuclex.UserInterface.ScreenTest.GamePadTestControl.HeldButtonCount">
            <summary>Number of game pad buttons being held down</summary>
        </member>
        <member name="T:Nuclex.UserInterface.ScreenTest.KeyboardTestControl">
            <summary>Control used to test keyboard notifications</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.KeyboardTestControl.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
            <returns>
              True if the key press was handled by the control, otherwise false.
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.KeyboardTestControl.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released again</summary>
            <param name="keyCode">Code of the key that was released</param>
        </member>
        <member name="F:Nuclex.UserInterface.ScreenTest.KeyboardTestControl.HeldKeyCount">
            <summary>Number of keys being held down</summary>
        </member>
        <member name="T:Nuclex.UserInterface.ScreenTest.MouseTestControl">
            <summary>Control used to test mouse notifications</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.MouseTestControl.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been pressed down</summary>
            <param name="keyCode">Code of the key that was pressed</param>
            <returns>
              True if the key press was handled by the control, otherwise false.
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.MouseTestControl.OnMousePressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed down</summary>
            <param name="button">Index of the button that has been pressed</param>
            <returns>Whether the control has processed the mouse press</returns>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.MouseTestControl.OnMouseReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released again</summary>
            <param name="button">Index of the button that has been released</param>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.MouseTestControl.OnMouseWheel(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks that the mouse wheel has been rotated</param>
        </member>
        <member name="F:Nuclex.UserInterface.ScreenTest.MouseTestControl.HeldMouseButtons">
            <summary>Mouse buttons being held down</summary>
        </member>
        <member name="F:Nuclex.UserInterface.ScreenTest.MouseTestControl.MouseWheelTicks">
            <summary>Ticks the mouse wheel has been rotated by</summary>
        </member>
        <member name="T:Nuclex.UserInterface.ScreenTest.CommandTestControl">
            <summary>Control for testing command routing</summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.CommandTestControl.OnCommand(Nuclex.UserInterface.Input.Command)">
            <summary>Called when an input command was sent to the control</summary>
            <param name="command">Input command that has been triggered</param>
            <returns>Whether the command has been processed by the control</returns>
        </member>
        <member name="T:Nuclex.UserInterface.ScreenTest.IFocusChangeSubscriber">
            <summary>
              Interface for a subscriber to a Control's FocusChanged event
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.ScreenTest.IFocusChangeSubscriber.FocusChanged(System.Object,Nuclex.UserInterface.Controls.ControlEventArgs)">
            <summary>Called when the focused control has changed</summary>
            <param name="sender">Screen that is reporting the focus change</param>
            <param name="arguments">Contains the control that is now focused</param>
        </member>
        <member name="T:Nuclex.UserInterface.UniScalarTest">
            <summary>Unit Test for the unified scalar class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestZeroValue">
            <summary>Validates the zero value provided by the unified scalar class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestOffsetConstructor">
            <summary>Verifies that the constructor accepting an offset is working</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestFullConstructor">
            <summary>
              Verifies that the full constructor of the unified scalar class is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestImplicitConstructor">
            <summary>
              Verifies that the implicit offset conversion constructor is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestToOffsetWithOffsetOnly">
            <summary>
              Verifies that the ToOffset() method converts a scalar consisting only of an offset
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestToOffsetWithNormalScalar">
            <summary>
              Verifies that the ToOffset() method converts a normal scalar
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestAdditionOperator">
            <summary>Tests the addition operator of the unified scalar class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestSubtractionOperator">
            <summary>Tests the subtraction operator of the unified scalar class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestMultiplicationOperator">
            <summary>Tests the multiplication operator of the unified scalar class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestDivisionOperator">
            <summary>Tests the division operator of the unified scalar class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestEqualityOperator">
            <summary>Tests the equality operator of the unified scalar class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestInequalityOperator">
            <summary>Test the inequality operator of the unified scalar class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestEqualsWithDowncast">
            <summary>
              Tests the Equals() method of the unified scalar class when it has to perform
              a downcast to obtain the comparison scalar
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestEqualsWithDifferentType">
            <summary>
              Tests the Equals() method of the unified scalar class against a different type
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestEqualsWithNullReference">
            <summary>
              Tests the Equals() method of the unified scalar class against a null pointer
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestGetHashCode">
            <summary>
              Tests the GetHashCode() method of the unified scalar class
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniScalarTest.TestToString">
            <summary>
              Tests the ToString() method of the unified scalar class
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.UniVector">
            <summary>Stores a two-dimensional position or size</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniVector.Zero">
            <summary>A vector that has been initialized to zero</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.#ctor(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniScalar)">
            <summary>Initializes a new vector from the provided components</summary>
            <param name="x">Absolute and relative X coordinate of the vector</param>
            <param name="y">Absolute and relative Y coordinate of the vector</param>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.ToOffset(Microsoft.Xna.Framework.Vector2)">
            <summary>Converts the vector into pure offset coordinates</summary>
            <param name="containerSize">
              Dimensions of the container the relative part of the vector counts for
            </param>
            <returns>An XNA vector with the pure offset coordinates of the vector</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.ToOffset(System.Single,System.Single)">
            <summary>Converts the vector into pure offset coordinates</summary>
            <param name="containerWidth">
              Width of the container the fractional part of the vector counts for
            </param>
            <param name="containerHeight">
              Height of the container the fractional part of the vector counts for
            </param>
            <returns>An XNA vector with the pure offset coordinates of the vector</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.op_Addition(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniVector)">
            <summary>Adds one vector to another</summary>
            <param name="vector">Base vector to add to</param>
            <param name="summand">Vector to add to the base</param>
            <returns>The result of the addition</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.op_Subtraction(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniVector)">
            <summary>Subtracts one vector from another</summary>
            <param name="vector">Base vector to subtract from</param>
            <param name="subtrahend">Vector to subtract from the base</param>
            <returns>The result of the subtraction</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.op_Division(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniVector)">
            <summary>Divides one vector by another</summary>
            <param name="vector">Base vector to be divided</param>
            <param name="divisor">Divisor to divide by</param>
            <returns>The result of the division</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.op_Multiply(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniVector)">
            <summary>Multiplies one vector with another</summary>
            <param name="vector">Base vector to be multiplied</param>
            <param name="factor">Factor to multiply by</param>
            <returns>The result of the multiplication</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.op_Multiply(Nuclex.UserInterface.UniScalar,Nuclex.UserInterface.UniVector)">
            <summary>Scales a vector by a scalar factor</summary>
            <param name="factor">Factor by which to scale the vector</param>
            <param name="vector">Vector to be Scaled</param>
            <returns>The result of the multiplication</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.op_Multiply(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniScalar)">
            <summary>Scales a vector by a scalar factor</summary>
            <param name="vector">Vector to be Scaled</param>
            <param name="factor">Factor by which to scale the vector</param>
            <returns>The result of the multiplication</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.op_Inequality(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniVector)">
            <summary>Checks two vectors for inequality</summary>
            <param name="first">First vector to be compared</param>
            <param name="second">Second vector to be compared</param>
            <returns>True if the instances differ or exactly one reference is set to null</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.op_Equality(Nuclex.UserInterface.UniVector,Nuclex.UserInterface.UniVector)">
            <summary>Checks two vectors for equality</summary>
            <param name="first">First vector to be compared</param>
            <param name="second">Second vector to be compared</param>
            <returns>True if both instances are equal or both references are null</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.Equals(System.Object)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.Equals(Nuclex.UserInterface.UniVector)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.GetHashCode">
            <summary>Obtains a hash code of this instance</summary>
            <returns>The hash code of the instance</returns>
        </member>
        <member name="M:Nuclex.UserInterface.UniVector.ToString">
            <summary>
              Returns a human-readable string representation for the unified vector
            </summary>
            <returns>The human-readable string representation of the unified vector</returns>
        </member>
        <member name="F:Nuclex.UserInterface.UniVector.X">
            <summary>The vector's X coordinate</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniVector.Y">
            <summary>The vector's Y coordinate</summary>
        </member>
        <member name="T:Nuclex.UserInterface.UniVectorTest">
            <summary>Unit Test for the unified vector class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestConstructor">
            <summary>Tests the constructor of the unified vector class</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestToOffset">
            <summary>Verifies that the ToOffset() method works as expected</summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestAdditionOperator">
            <summary>
              Verifies that the addition operator of the unified vector is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestSubtractionOperator">
            <summary>
              Verifies that the subtraction operator of the unified vector is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestMultiplicationOperator">
            <summary>
              Verifies that the multiplication operator of the unified vector is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestMultiplicationOperatorWithScalarOnLeftSide">
            <summary>
              Verifies that the multiplication operator of the unified vector can be used
              to multiply a scalar by the vector
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestMultiplicationOperatorWithScalarInRightSide">
            <summary>
              Verifies that the multiplication operator of the unified vector can be used
              to multiply the vector by a scalar
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestDivisionOperator">
            <summary>
              Verifies that the division operator of the unified vector is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestEqualityOperator">
            <summary>
              Verifies that the equality operator of the unified vector is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestInequalityOperator">
            <summary>
              Verifies that the inequality operator of the unified vector is working
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestEqualsWithDowncast">
            <summary>
              Tests the Equals() method of the unified vector class when it has to perform
              a downcast to obtain the comparison vector
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestEqualsWithDifferentType">
            <summary>
              Tests the Equals() method of the unified vector class against a different type
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestEqualsWithNullReference">
            <summary>
              Tests the Equals() method of the unified vector class against a null pointer
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestGetHashCode">
            <summary>
              Tests the GetHashCode() method of the unified vector class
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.UniVectorTest.TestToString">
            <summary>
              Tests the ToString() method of the unified vector class
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniVectorTest.firstTestScalar">
            <summary>First value used for testing in the individual unit test methods</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniVectorTest.secondTestScalar">
            <summary>Second value used for testing in the individual unit test methods</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniVectorTest.thirdTestScalar">
            <summary>Third value used for testing in the individual unit test methods</summary>
        </member>
        <member name="F:Nuclex.UserInterface.UniVectorTest.fourthTestScalar">
            <summary>Fourth value used for testing in the individual unit test methods</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics">
            <summary>Graphics interface for the traditional flat GUI visualizer</summary>
            <remarks>
              This class is analog to System.Drawing.Graphics, but contains specialized
              methods that allow the FlatControlRenderers to draw controls from
              high-level elements which are controlled by loadable XML themes.
            </remarks>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics">
            <summary>Provides drawing methods for GUI controls</summary>
            <remarks>
              Analogous to System.Drawing.Graphics, but provides specialized methods for
              drawing a GUI with a dynamic, switchable theme.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics.SetClipRegion(Nuclex.UserInterface.RectangleF)">
            <summary>Sets the clipping region for any future drawing commands</summary>
            <param name="clipRegion">Clipping region that will be set</param>
            <returns>
              An object that will unset the clipping region upon its destruction.
            </returns>
            <remarks>
              Clipping regions can be stacked, though this is not very typical for
              a game GUI and also not recommended practice due to performance constraints.
              Unless clipping is implemented in software, setting up a clip region
              on current hardware requires the drawing queue to be flushed, negatively
              impacting rendering performance (in technical terms, a clipping region
              change likely causes 2 more DrawPrimitive() calls from the painter).
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics.DrawElement(System.String,Nuclex.UserInterface.RectangleF)">
            <summary>Draws a GUI element onto the drawing buffer</summary>
            <param name="frameName">Class of the element to draw</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <remarks>
              <para>
                GUI elements are the basic building blocks of a GUI: 
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics.DrawString(System.String,Nuclex.UserInterface.RectangleF,System.String)">
            <summary>Draws text into the drawing buffer for the specified element</summary>
            <param name="frameName">Class of the element for which to draw text</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <param name="text">Text that will be drawn</param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics.DrawCaret(System.String,Nuclex.UserInterface.RectangleF,System.String,System.Int32)">
            <summary>Draws a caret for text input at the specified index</summary>
            <param name="frameName">Class of the element for which to draw a caret</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <param name="text">Text for which a caret will be drawn</param>
            <param name="index">Index the caret will be drawn at</param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics.MeasureString(System.String,Nuclex.UserInterface.RectangleF,System.String)">
            <summary>Measures the extents of a string in the frame's area</summary>
            <param name="frameName">Class of the element whose text will be measured</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <param name="text">Text that will be measured</param>
            <returns>
              The size and extents of the specified string within the frame
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics.GetClosestOpening(System.String,Nuclex.UserInterface.RectangleF,System.String,Microsoft.Xna.Framework.Vector2)">
            <summary>
              Locates the closest gap between two letters to the provided position
            </summary>
            <param name="frameName">Class of the element in which to find the gap</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <param name="text">Text in which the closest gap will be found</param>
            <param name="position">Position of which to determien the closest gap</param>
            <returns>The index of the gap the position is closest to</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.CaretWidth">
            <summary>Width of the caret used for text input</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.BeginDrawing">
            <summary>Needs to be called before the GUI drawing process begins</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.EndDrawing">
            <summary>Needs to be called when the GUI drawing process has ended</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.SetClipRegion(Nuclex.UserInterface.RectangleF)">
            <summary>Sets the clipping region for any future drawing commands</summary>
            <param name="clipRegion">Clipping region that will be set</param>
            <returns>
              An object that will unset the clipping region upon its destruction.
            </returns>
            <remarks>
              Clipping regions can be stacked, though this is not very typical for
              a game GUI and also not recommended practice due to performance constraints.
              Unless clipping is implemented in software, setting up a clip region
              on current hardware requires the drawing queue to be flushed, negatively
              impacting rendering performance (in technical terms, a clipping region
              change likely causes 2 more DrawPrimitive() calls from the painter).
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.DrawElement(System.String,Nuclex.UserInterface.RectangleF)">
            <summary>Draws a GUI element onto the drawing buffer</summary>
            <param name="frameName">Class of the element to draw</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <remarks>
              <para>
                GUI elements are the basic building blocks of a GUI: 
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.DrawString(System.String,Nuclex.UserInterface.RectangleF,System.String)">
            <summary>Draws text into the drawing buffer for the specified element</summary>
            <param name="frameName">Class of the element for which to draw text</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <param name="text">Text that will be drawn</param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.DrawCaret(System.String,Nuclex.UserInterface.RectangleF,System.String,System.Int32)">
            <summary>Draws a caret for text input at the specified index</summary>
            <param name="frameName">Class of the element for which to draw a caret</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <param name="text">Text for which a caret will be drawn</param>
            <param name="caretIndex">Index the caret will be drawn at</param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.MeasureString(System.String,Nuclex.UserInterface.RectangleF,System.String)">
            <summary>Measures the extents of a string in the frame's area</summary>
            <param name="frameName">Class of the element whose text will be measured</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <param name="text">Text that will be measured</param>
            <returns>
              The size and extents of the specified string within the frame
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.GetClosestOpening(System.String,Nuclex.UserInterface.RectangleF,System.String,Microsoft.Xna.Framework.Vector2)">
            <summary>
              Locates the closest gap between two letters to the provided position
            </summary>
            <param name="frameName">Class of the element in which to find the gap</param>
            <param name="bounds">Region that will be covered by the drawn element</param>
            <param name="text">Text in which the closest gap will be found</param>
            <param name="position">Position of which to determien the closest gap</param>
            <returns>The index of the gap the position is closest to</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.beginSpriteBatch">
            <summary>Starts drawing on the sprite batch</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.endSpriteBatch">
            <summary>Stops drawing on the sprite batch</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.#ctor(Microsoft.Xna.Framework.Content.ContentManager,System.IO.Stream)">
            <summary>Initializes a new gui painter</summary>
            <param name="contentManager">
              Content manager containing the resources for the GUI. The instance takes
              ownership of the content manager and will dispose it.
            </param>
            <param name="skinStream">
              Stream from which the skin description will be read
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.positionText(Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Text@,Nuclex.UserInterface.RectangleF,System.String)">
            <summary>
              Positions a string within a frame according to the positioning instructions
              stored in the provided text anchor.
            </summary>
            <param name="anchor">Text anchor the string will be positioned for</param>
            <param name="bounds">Boundaries of the control the string is rendered in</param>
            <param name="text">String that will be positioned</param>
            <returns>The position of the string within the control</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.calculateDestinationRectangle(Nuclex.UserInterface.RectangleF@,Nuclex.UserInterface.UniRectangle@)">
            <summary>
              Calculates the absolute pixel position of a rectangle in unified coordinates
            </summary>
            <param name="bounds">Bounds of the drawing area in pixels</param>
            <param name="destination">Destination rectangle in unified coordinates</param>
            <returns>
              The destination rectangle converted to absolute pixel coordinates
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.lookupFrame(System.String)">
            <summary>Looks up the frame with the specified name</summary>
            <param name="frameName">Frame that will be looked up</param>
            <returns>The frame with the specified name</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.floor(System.Single)">
            <summary>Removes the fractional part from the floating point value</summary>
            <param name="value">Value whose fractional part will be removed</param>
            <returns>The floating point value without its fractional part</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.stringBuilder">
            <summary>String builder used for various purposes in this class</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.openingLocator">
            <summary>Locates openings between letters in strings</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.scissorManager">
            <summary>Manages the scissor rectangle and its assignment time</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.spriteBatch">
            <summary>Batches GUI elements for faster drawing</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.contentManager">
            <summary>Manages the content used to draw the GUI</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.fonts">
            <summary>Font styles known to the GUI</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.bitmaps">
            <summary>Bitmaps containing resources for the GUI</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.frames">
            <summary>Types of frames the painter can draw</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.rasterizerState">
            <summary>Rasterizer state used for drawing the GUI</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.loadSkin(System.IO.Stream)">
            <summary>Loads a skin from the specified path</summary>
            <param name="skinStream">Stream containing the skin description</param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.loadResources(System.Xml.Linq.XDocument)">
            <summary>Loads the resources contained in a skin document</summary>
            <param name="skinDocument">
              XML document containing a skin description whose resources will be loaded
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.loadFrames(System.Xml.Linq.XDocument)">
            <summary>Loads the frames contained in a skin document</summary>
            <param name="skinDocument">
              XML document containing a skin description whose frames will be loaded
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.getResourceStream(System.String)">
            <summary>Returns a stream for a resource embedded in this assembly</summary>
            <param name="resourceName">Name of the resource for which to get a stream</param>
            <returns>A stream for the specified embedded resource</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.colorFromString(System.String)">
            <summary>Converts a string in the style "#rrggbb" into a Color value</summary>
            <param name="color">String containing a hexadecimal color value</param>
            <returns>The equivalent color as a Color value</returns>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame">
            <summary>Frame that can be drawn by the GUI painter</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.#ctor(Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Region[],Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Text[])">
            <summary>Initializes a new frame</summary>
            <param name="regions">Regions needed to be drawn to render the frame</param>
            <param name="texts">Location in the frame where text can be drawn</param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Regions">
            <summary>Regions that need to be drawn to render the frame</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Texts">
            <summary>Locations where text can be drawn into the frame</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.HorizontalTextAlignment">
            <summary>Modes in which text can be horizontally aligned</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.HorizontalTextAlignment.Left">
            <summary>The text's base offset is placed at the left of the frame</summary>
            <remarks>
              The base offset is normally identical to the text's leftmost pixel.
              However, a glyph may have some eccentrics like an arc that extends to
              the left over the letter's actual starting position.
            </remarks>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.HorizontalTextAlignment.Right">
            <summary>
              The text's ending offset is placed at the right of the frame
            </summary>
            <remarks>
              The ending offset is normally identical to the text's rightmost pixel.
              However, a glyph may have some eccentrics like an arc that extends to
              the right over the last letter's actual ending position.
            </remarks>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.HorizontalTextAlignment.Center">
            <summary>The text is centered horizontally in the frame</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.VerticalTextAlignment">
            <summary>Modes in which text can be vertically aligned</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.VerticalTextAlignment.Top">
            <summary>The text's baseline is placed at the top of the frame</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.VerticalTextAlignment.Bottom">
            <summary>The text's baseline is placed at the bottom of the frame</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.VerticalTextAlignment.Center">
            <summary>The text's baseline is centered vertically in the frame</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Region">
            <summary>Defines a picture region drawn into a frame</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Region.Id">
            <summary>Identification string for the region</summary>
            <remarks>
              Used to associate regions with specific behavior
            </remarks>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Region.Texture">
            <summary>Texture the picture region is taken from</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Region.SourceRegion">
            <summary>Area within the texture containing the picture region</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Region.DestinationRegion">
            <summary>Location in the frame where the picture region will be drawn</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Text">
            <summary>Describes where within the frame text should be drawn</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Text.Font">
            <summary>Font to use for drawing the text</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Text.Offset">
            <summary>Offset of the text relative to its specified placement</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Text.HorizontalPlacement">
            <summary>Horizontal placement of the text within the frame</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Text.VerticalPlacement">
            <summary>Vertical placement of the text within the frame</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.Frame.Text.Color">
            <summary>Color the text will have</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.ScissorKeeper">
            <summary>Manages the scissor rectangle for the GUI graphics interface</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.ScissorKeeper.#ctor(Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics)">
            <summary>Initializes a new scissor manager</summary>
            <param name="flatGuiGraphics">
              GUI graphics interface the scissor rectangle will be managed for
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.ScissorKeeper.Assign(Microsoft.Xna.Framework.Rectangle@)">
            <summary>Assigns the scissor rectangle to the graphics device</summary>
            <param name="clipRegion">Scissor rectangle that will be assigned</param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.ScissorKeeper.Dispose">
            <summary>Releases the currently assigned scissor rectangle again</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.ScissorKeeper.flatGuiGraphics">
            <summary>
              GUI graphics interface for which the scissor rectangle is managed
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.ScissorKeeper.oldScissorRectangle">
            <summary>
              Scissor rectangle that was previously assigned to the graphics device
            </summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder">
            <summary>Builds a region list from the regions in an frame XML node</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.#ctor">
            <summary>Initializes a new frame region list builder</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.Build(System.Xml.Linq.XElement,System.Collections.Generic.IDictionary{System.String,Microsoft.Xna.Framework.Graphics.Texture2D})">
            <summary>
              Builds a region list from the regions specified in the provided frame XML node
            </summary>
            <param name="frameElement">
              XML node for the frame whose regions wille be processed
            </param>
            <param name="bitmaps">
              Bitmap lookup table used to associate a region's bitmap id to the real bitmap
            </param>
            <returns>
              A list of the regions that have been extracted from the frame XML node
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.retrieveBorderSizes(System.Xml.Linq.XElement)">
            <summary>Retrieves the sizes of the border regions in a frame</summary>
            <param name="frameElement">
              XML node for the frame containing the region
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.createAndPlaceRegions(System.Xml.Linq.XElement,System.Collections.Generic.IDictionary{System.String,Microsoft.Xna.Framework.Graphics.Texture2D})">
            <summary>
              Creates and places the regions needed to be drawn to render the frame
            </summary>
            <param name="frameElement">
              XML node for the frame containing the region
            </param>
            <param name="bitmaps">
              Bitmap lookup table to associate a region's bitmap id to the real bitmap
            </param>
            <returns>The regions created for the frame</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.calculateRegionPlacement(System.Int32,System.Int32,System.Int32,System.Int32,Nuclex.UserInterface.UniScalar@,Nuclex.UserInterface.UniScalar@)">
            <summary>
              Calculates the unified coordinates a region needs to be placed at
            </summary>
            <param name="placementIndex">
              Placement index indicating where in a frame the region will be located
            </param>
            <param name="width">Width of the region in pixels</param>
            <param name="lowBorderWidth">
              Width of the border on the lower end of the coordinate range
            </param>
            <param name="highBorderWidth">
              Width of the border on the higher end of the coordinate range
            </param>
            <param name="location">
              Receives the target location of the region in unified coordinates
            </param>
            <param name="size">
              Receives the size of the region in unified coordinates
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.getHorizontalPlacementIndex(System.String)">
            <summary>Converts a horizontal placement string into a placement index</summary>
            <param name="placement">String containing the horizontal placement</param>
            <returns>A placement index that is equivalent to the provided string</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.getVerticalPlacementIndex(System.String)">
            <summary>Converts a vertical placement string into a placement index</summary>
            <param name="placement">String containing the vertical placement</param>
            <returns>A placement index that is equivalent to the provided string</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.leftBorderWidth">
            <summary>Width of the frame's left border regions</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.topBorderWidth">
            <summary>Width of the frame's top border regions</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.rightBorderWidth">
            <summary>Width of the frame's right border regions</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.RegionListBuilder.bottomBorderWidth">
            <summary>Width of the frame's bottom border regions</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.TextListBuilder">
            <summary>Builds a text list from the regions in an frame XML node</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.TextListBuilder.Build(System.Xml.Linq.XElement,System.Collections.Generic.IDictionary{System.String,Microsoft.Xna.Framework.Graphics.SpriteFont})">
            <summary>
              Builds a text list from the text placements specified in the provided node
            </summary>
            <param name="frameElement">
              XML node for the frame whose text placements wille be processed
            </param>
            <param name="fonts">
              Font lookup table used to associate a text's font id to the real font
            </param>
            <returns>
              A list of the texts that have been extracted from the frame XML node
            </returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.TextListBuilder.horizontalPlacementFromString(System.String)">
            <summary>Converts a string into a horizontal placement enumeration value</summary>
            <param name="placement">Placement string that will be converted</param>
            <returns>The horizontal placement enumeration value matching the string</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphics.TextListBuilder.verticalPlacementFromString(System.String)">
            <summary>Converts a string into a vertical placement enumeration value</summary>
            <param name="placement">Placement string that will be converted</param>
            <returns>The vertical placement enumeration value matching the string</returns>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest">
            <summary>Unit tests for flat GUI graphics interface</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestConstructor">
            <summary>Verifies that the painter's constructor is working</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestClipRegion">
            <summary>Verifies that the painter can assign a clipping region</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestClipRegionOffScreen">
            <summary>
              Verifies that the painter can handle a clipping region that leaves
              the viewport
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestDrawElement">
            <summary>Verifies that the painter can draw skin elements</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestDrawString">
            <summary>Verifies that the painter can draw strings</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestDrawCaret">
            <summary>Verifies that the painter can draw a text cursor (caret)</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestMeasureString">
            <summary>Verifies that the painter can measure the size of a string</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestMeasureStringOnTextlessFrame">
            <summary>
              Verifies that the painter can measure the size of a string drawn to a frame
              which contains no text
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestGetClosestOpening">
            <summary>
              Verifies that the painter can locate the opening between two characters
              in a string that's closest to a specific position
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestStringPositioning">
            <summary>Tests whether strings can be positioned at all anchoring spots</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestThrowOnMissingFrame">
            <summary>
              Tests whether an exception is thrown if a skin element doesn't exist
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestThrowOnBadColor">
            <summary>
              Tests whether an exception is thrown if a skin contains an bad color constant
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestThrowOnBadHorizontalPosition">
            <summary>
              Tests whether an exception is thrown if a skin contains an bad horizontal
              text position
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.TestThrowOnBadVerticalPosition">
            <summary>
              Tests whether an exception is thrown if a skin contains an bad horizontal
              text position
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.mockedGraphicsDeviceService">
            <summary>Mocked graphics device used to run the unit tests</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.contentManager">
            <summary>Content manager holding the resources of the painter's skin</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiGraphicsTest.graphics">
            <summary>GUI graphics interface being tested</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest">
            <summary>Unit tests for flat GUI visualizer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestConstructFromFile">
            <summary>
              Verifies that a flat GUI visualizer can be constructed from a file
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestThrowOnConstructFromBrokenFile">
            <summary>
              Verifies that a flat GUI visualizer can handle exceptions during loading
              from a file
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestConstructFromResource">
            <summary>
              Verifies that a flat GUI visualizer can be constructed from a resource
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestThrowOnConstructFromNonExistingResource">
            <summary>
              Verifies that a flat GUI visualizer can handle exceptions when attempting
              to load a non-existing resource
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestThrowOnConstructFromBrokenResource">
            <summary>
              Verifies that a flat GUI visualizer can handle exceptions during loading
              from a resource containing a broken skin description
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestDraw">
            <summary>
              Verifies that a flat GUI visualizer can handle exceptions during loading
              from a resource containing a broken skin description
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestDrawNonRenderableControl">
            <summary>
              Tests whether the visualizer can cope with a non-renderable control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestEmployAmbiguousRenderers">
            <summary>
              Tests whether the visualizer can cope with a non-renderable control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestCannotEmployNonRendererType">
            <summary>
              Tests whether the visualizer can cope with a non-renderable control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestCannotEmployNonConstructableRenderer">
            <summary>
              Tests whether the visualizer can cope with a non-renderable control
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.TestAccessControlRepository">
            <summary>
              Verifies that the visualizer's control renderer repository can be accessed
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.mockedGraphicsDeviceService">
            <summary>Mocked graphics device used for running the unit tests</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.ResourceFileKeeper">
            <summary>
              Temporarily extracts the unit test resources to the local file system
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.ResourceFileKeeper.#ctor">
            <summary>Initializes a new resource file keeper</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.ResourceFileKeeper.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.ResourceFileKeeper.extractResource(System.Byte[],System.String)">
            <summary>Extracts the specified resource to the provided file</summary>
            <param name="resource">Resource that will be extracted</param>
            <param name="file">File to which the resource will be written</param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.ResourceFileKeeper.tempFile">
            <summary>
              Temporary file created by the OS and kept around until the instance is
              disposed to occupy the temp file name
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.ResourceFileKeeper.tempPath">
            <summary>
              Path to the temporary directory the resources are extracted into
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.ResourceFileKeeper.ResourcePath">
            <summary>Directory into which the resources were extracted</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.NonRenderableControl">
            <summary>Control for which no renderer exists</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.NotAControlRenderer">
            <summary>Dummy class that is not a control renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.IFlatControlRenderer">
            <summary>Interface for a class that renders a control</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.LabelControlRenderer1">
            <summary>First of two ambiguous renderers for the label control</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.IFlatControlRenderer`1">
            <summary>
              Interface for a class responsible to render a specific control type
            </summary>
            <typeparam name="ControlType">
              Type of control the implementation class will render
            </typeparam>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.IFlatControlRenderer`1.Render(`0,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.LabelControlRenderer2">
            <summary>Second of two ambiguous renderers for the label control</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.MultiInterfaceControlRenderer">
            <summary>Control renderer which implements multiple interfaces</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizerTest.NonConstructableRenderer">
            <summary>Control renderer which cannot be constructed publicly</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.OpeningLocator">
            <summary>
              Locates the opening between characters in a string that is nearest
              to a user-defined location
            </summary>
            <remarks>
              <para>
                This is a class rather than a static class to prevent garbage production
                which would then have to be cleaned up again by the garbage collector.
                If you create an instance of it and keep reusing it, garbage and allocation
                will amortize.
              </para>
              <para>
                The method used to calculate the openings seems to be not terribly accurate.
                As of XNA 3.1, SpriteFonts don't do kerning, so the only thing left would be
                a variable space appended to the end of characters. This could be compensated
                for by always appending character with a known length for which no kerning is
                possible, for example, the pipe sign (|).
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.OpeningLocator.#ctor">
            <summary>Initializes a new text opening locator</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.OpeningLocator.FindClosestOpening(Microsoft.Xna.Framework.Graphics.SpriteFont,System.String,System.Single)">
            <summary>
              Locates the opening between two letters that is closest to
              the specified position
            </summary>
            <param name="font">Font that opening search will use</param>
            <param name="text">Text that will be searched for the opening</param>
            <param name="x">X coordinate closest to which an opening will be found</param>
            <returns>The opening closest to the specified X coordinate</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.OpeningLocator.textBuilder">
            <summary>Used by GetClosestOpening() to avoid garbage production</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest">
            <summary>Unit tests for character opening locator</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest.TestLocateOpeningWithin">
            <summary>
              Verifies that the character opening locator can locate an opening between
              two letter within the text
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest.TestLocateOpeningBefore">
            <summary>
              Verifies that the character opening locator works if the searched location
              lies before the text start
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest.TestLocateOpeningAfter">
            <summary>
              Verifies that the character opening locator works if the searched location
              lies after the text end
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest.TestLocateOpeningOnSingleCharacter">
            <summary>
              Verifies that the character opening locator works if only a single character
              should be scanned for an opening
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest.mockedGraphicsDeviceService">
            <summary>Mocked graphics device used for the unit tests</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest.contentManager">
            <summary>Content manager for loading the unit test assets</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.OpeningLocatorTest.unitTestSpriteFont">
            <summary>Sprite font used in the unit test</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.ControlRendererTest">
            <summary>Base class for control renderer unit tests</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.ControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.ControlRendererTest.TearDown">
            <summary>Called after each test is run</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.ControlRendererTest.screen">
            <summary>Screen the tested control can be placed on</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.ControlRendererTest.mockedGraphics">
            <summary>Graphics interface used for rendering the GUI</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.ControlRendererTest.mockery">
            <summary>Mockery used to create the mocked graphics interface</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Visuals.Flat.Renderers.ControlRendererTest.Mockery">
            <summary>Mockery used to create the mocked graphics interface</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Visuals.Flat.Renderers.ControlRendererTest.MockedGraphics">
            <summary>Mocked graphics interface the GUI can be tested on</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Visuals.Flat.Renderers.ControlRendererTest.Screen">
            <summary>Screen the controls can be placed on for testing</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRenderer">
            <summary>Renders button controls in a traditional flat style</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRenderer.Render(Nuclex.UserInterface.Controls.Desktop.ButtonControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRenderer.states">
            <summary>Names of the states the button control can be in</summary>
            <remarks>
              Storing this as full strings instead of building them dynamically prevents
              any garbage from forming during rendering.
            </remarks>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer">
            <summary>Draws traditional flat GUIs using 2D bitmaps</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.FromFile(System.IServiceProvider,System.String)">
            <summary>Initializes a new gui visualizer from a skin stored in a file</summary>
            <param name="serviceProvider">
              Game service provider containing the graphics device service
            </param>
            <param name="skinPath">
              Path to the skin description this GUI visualizer will load
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.FromResource(System.IServiceProvider,System.Resources.ResourceManager,System.String)">
            <summary>Initializes a new gui visualizer from a skin stored as a resource</summary>
            <param name="serviceProvider">
              Game service provider containing the graphics device service
            </param>
            <param name="resourceManager">
              Resource manager containing the resources used in the skin
            </param>
            <param name="skinResource">
              Name of the resource containing the skin description
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.#ctor(Microsoft.Xna.Framework.Content.ContentManager,System.IO.Stream)">
            <summary>Initializes a new gui painter for traditional GUIs</summary>
            <param name="contentManager">
              Content manager that will be used to load the skin resources
            </param>
            <param name="skinStream">
              Stream from which the GUI Visualizer will read the skin description
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.Draw(Nuclex.UserInterface.Screen)">
            <summary>Draws an entire GUI hierarchy</summary>
            <param name="screen">Screen containing the GUI that will be drawn</param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.renderControl(Nuclex.UserInterface.Controls.Control)">
            <summary>Renders a single control</summary>
            <param name="controlToRender">Control that will be rendered</param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.pluginHost">
            <summary>Holds the assemblies we have employed for our cause</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.employer">
            <summary>Carries the employed control renderers</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.flatGuiGraphics">
            <summary>Used to draw the individual building elements of the GUI</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.controlStack">
            <summary>Helps draw the GUI controls in the hierarchically correct order</summary>
            <remarks>
              This is a field and not a local variable because the stack allocates
              heap memory and we don't want that to happen in a frame-by-frame basis on
              the compact framework. By reusing the same stack over and over, the amount
              of heap allocations required will amortize itself.
            </remarks>
        </member>
        <member name="P:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.RendererRepository">
            <summary>
              Plugin repository from which renderers for GUI controls are taken
            </summary>
        </member>
        <member name="P:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.Self">
            <summary>Returns the assembly containing the GUI visualizer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlWithBounds">
            <summary>Container for a control and its absolute boundaries</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlWithBounds.#ctor(Nuclex.UserInterface.Controls.Control,Nuclex.UserInterface.RectangleF)">
            <summary>Initializes a new control and absolute boundary container</summary>
            <param name="control">Control being store in the container</param>
            <param name="bounds">Absolute boundaries the control lives in</param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlWithBounds.FromControl(Nuclex.UserInterface.Controls.Control,Nuclex.UserInterface.RectangleF)">
            <summary>
              Builds an absolute boundary container from the provided control
            </summary>
            <param name="control">Control from which a container will be created</param>
            <param name="containerBounds">
              Absolute boundaries of the control's parent
            </param>
            <returns>A new container with the control</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlWithBounds.FromScreen(Nuclex.UserInterface.Screen)">
            <summary>
              Builds a control and absolute boundary container from a screen
            </summary>
            <param name="screen">
              Screen whose desktop control and absolute boundaries are used to
              construct the container
            </param>
            <returns>A new container with the screen's desktop control</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlWithBounds.Control">
            <summary>Control stored in the container</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlWithBounds.Bounds">
            <summary>Absolute boundaries of the stored control</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.IControlRendererAdapter">
            <summary>Interface for a generic (typeless) control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.IControlRendererAdapter.Render(Nuclex.UserInterface.Controls.Control,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="controlToRender">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to render the control
            </param>
        </member>
        <member name="P:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.IControlRendererAdapter.AdaptedType">
            <summary>The type of the control renderer being adapted</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererAdapter`1">
            <summary>
              Adapter that automatically casts a control down to the renderer's supported
              control type
            </summary>
            <typeparam name="ControlType">
              Type of control the control renderer casts down to
            </typeparam>
            <remarks>
              This is simply an optimization to avoid invoking the control renderer
              by reflection (using the Invoke() method) which would require us to construct
              an object[] array on the heap to pass its arguments.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererAdapter`1.#ctor(Nuclex.UserInterface.Visuals.Flat.IFlatControlRenderer{`0})">
            <summary>Initializes a new control renderer adapter</summary>
            <param name="controlRenderer">Control renderer the adapter is used for</param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererAdapter`1.Render(Nuclex.UserInterface.Controls.Control,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="controlToRender">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to render the control
            </param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererAdapter`1.controlRenderer">
            <summary>Control renderer this adapter is performing the downcast for</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererAdapter`1.AdaptedType">
            <summary>The type of the control renderer being adapted</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererEmployer">
            <summary>
              Employs concrete types implementing IFlatGuiControlRenderer&lt;&gt;
            </summary>
            <remarks>
              This employer actually looks for concrete implementations using a variant
              of the IFlatGuiControlRenderer&lt;&gt; interface, regardless of the
              type it has been realized for.
            </remarks>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererEmployer.#ctor">
            <summary>Initializes a new control renderer employer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererEmployer.CanEmploy(System.Type)">
            <summary>Determines whether the type suites the employer's requirements</summary>
            <param name="type">Type that is checked for employability</param>
            <returns>True if the type can be employed</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererEmployer.Employ(System.Type)">
            <summary>Employs the specified plugin type</summary>
            <param name="type">Type to be employed</param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererEmployer.renderers">
            <summary>Employed renderers</summary>
        </member>
        <member name="P:Nuclex.UserInterface.Visuals.Flat.FlatGuiVisualizer.ControlRendererEmployer.Renderers">
            <summary>Renderers that were employed to the plugin host</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRendererTest">
            <summary>Unit Test for the flat button control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRendererTest.TestRenderDisabled">
            <summary>
              Verifies that the button renderer can render disabled buttons
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRendererTest.TestRenderNormal">
            <summary>
              Verifies that the button renderer can render normal buttons
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRendererTest.TestRenderHighlighted">
            <summary>
              Verifies that the button renderer can render highlighted buttons
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRendererTest.TestRenderDepressed">
            <summary>
              Verifies that the button renderer can render depressed buttons
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRendererTest.drawAndExpectState(System.String)">
            <summary>
              Lets the renderer draw the button and verifies that the button used
              the skin elements from the expected state
            </summary>
            <param name="expectedState">
              Expected state the skin elements should be using
            </param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRendererTest.renderer">
            <summary>Button renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatButtonControlRendererTest.button">
            <summary>Button used to test the button renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRenderer">
            <summary>Renders choice controls in a traditional flat style</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRenderer.Render(Nuclex.UserInterface.Controls.Desktop.ChoiceControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRenderer.states">
            <summary>Names of the states the choice control can be in</summary>
            <remarks>
              Storing this as full strings instead of building them dynamically prevents
              any garbage from forming during rendering.
            </remarks>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRendererTest">
            <summary>Unit Test for the flat choice control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRendererTest.TestRenderDisabled">
            <summary>
              Verifies that the choice control renderer can render disabled choices
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRendererTest.TestRenderNormal">
            <summary>
              Verifies that the choice control renderer can render normal choices
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRendererTest.TestRenderHighlighted">
            <summary>
              Verifies that the choice control renderer can render highlighted choices
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRendererTest.TestRenderDepressed">
            <summary>
              Verifies that the choice control renderer can render depressed choices
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRendererTest.drawAndExpectState(System.String)">
            <summary>
              Lets the renderer draw the choice control and verifies that the choice used
              the skin elements from the expected state
            </summary>
            <param name="expectedState">
              Expected state the skin elements should be using
            </param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRendererTest.renderer">
            <summary>Choice control renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatChoiceControlRendererTest.choice">
            <summary>Choice control used to test the choice control renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRenderer">
            <summary>Renders horizontal sliders in a traditional flat style</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRenderer.Render(Nuclex.UserInterface.Controls.Desktop.HorizontalSliderControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRendererTest">
            <summary>Unit Test for the flat horizontal slider control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRendererTest.TestRenderNormal">
            <summary>
              Verifies that the slider renderer can render normal sliders
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRendererTest.TestRenderHighlighted">
            <summary>
              Verifies that the slider renderer can render highlighted sliders
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRendererTest.TestRenderDepressed">
            <summary>
              Verifies that the slider renderer can render depressed sliders
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRendererTest.drawAndExpectState(System.String)">
            <summary>
              Lets the renderer draw the slider and verifies that the slider used
              the skin elements from the expected state
            </summary>
            <param name="expectedState">
              Expected state the skin elements should be using
            </param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRendererTest.renderer">
            <summary>Slider renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatHorizontalSliderControlRendererTest.slider">
            <summary>Slider used to test the slider renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRendererTest">
            <summary>Unit Test for the flat input control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRendererTest.TestRenderNormal">
            <summary>Verifies that the renderer is able to render the input control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRendererTest.TestRenderFocused">
            <summary>
              Verifies that the renderer is able to render the input control when it has
              the input focus
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRendererTest.TestOpeningLocator">
            <summary>
              Verifies that the renderer can provide the control with the text opening
              the user has clicked into to position the caret.
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRendererTest.renderer">
            <summary>Input control renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRendererTest.input">
            <summary>Input control used to test the input control renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatLabelControlRenderer">
            <summary>Renders label controls in a traditional flat style</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatLabelControlRenderer.Render(Nuclex.UserInterface.Controls.LabelControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatLabelControlRendererTest">
            <summary>Unit Test for the flat label control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatLabelControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatLabelControlRendererTest.TestRenderNormal">
            <summary>Verifies that the renderer is able to render the label</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatLabelControlRendererTest.renderer">
            <summary>Label renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatLabelControlRendererTest.label">
            <summary>Label used to test the label renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRenderer">
            <summary>Renders text input controls in a traditional flat style</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRenderer.Style">
            <summary>Style used to draw this control</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRenderer.Render(Nuclex.UserInterface.Controls.Desktop.ListControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRenderer.GetRow(Nuclex.UserInterface.RectangleF,System.Single,System.Int32,System.Single)">
            <summary>Calculates the list row the cursor is in</summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <param name="thumbPosition">
              Position of the thumb in the list's slider
            </param>
            <param name="itemCount">
              Number of items contained in the list
            </param>
            <param name="y">Vertical position of the cursor</param>
            <returns>The row the cursor is over</returns>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRenderer.GetRowHeight(Nuclex.UserInterface.RectangleF)">
            <summary>Determines the height of a row displayed in the list</summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <returns>The height of a single row in the list</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRenderer.rowHeight">
            <summary>Height of a single row in the list</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRenderer.graphics">
            <summary>Graphics interface we used for the last draw call</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRendererTest">
            <summary>Unit Test for the flat list control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRendererTest.TestRenderNormal">
            <summary>
              Verifies that the list renderer can render normal lists
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRendererTest.TestClickItem">
            <summary>
              Tests whether the renderer can provide the list with the row the user
              has clicked on
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRendererTest.drawAndExpectState">
            <summary>
              Lets the renderer draw the list and verifies that the list used
              the skin elements from the expected state
            </summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRendererTest.renderer">
            <summary>List renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatListControlRendererTest.list">
            <summary>List used to test the list renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRenderer">
            <summary>Renders option controls in a traditional flat style</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRenderer.Render(Nuclex.UserInterface.Controls.Desktop.OptionControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRenderer.states">
            <summary>Names of the states the option control can be in</summary>
            <remarks>
              Storing this as full strings instead of building them dynamically prevents
              any garbage from forming during rendering.
            </remarks>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRendererTest">
            <summary>Unit Test for the flat option control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRendererTest.TestRenderDisabled">
            <summary>
              Verifies that the option control renderer can render disabled options
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRendererTest.TestRenderNormal">
            <summary>
              Verifies that the option control renderer can render normal options
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRendererTest.TestRenderHighlighted">
            <summary>
              Verifies that the option control renderer can render highlighted options
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRendererTest.TestRenderDepressed">
            <summary>
              Verifies that the option control renderer can render depressed options
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRendererTest.drawAndExpectState(System.String)">
            <summary>
              Lets the renderer draw the option control and verifies that the option used
              the skin elements from the expected state
            </summary>
            <param name="expectedState">
              Expected state the skin elements should be using
            </param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRendererTest.renderer">
            <summary>Option control renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatOptionControlRendererTest.option">
            <summary>Option control used to test the option control renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatPanelControlRenderer">
            <summary>Renders panel controls in a traditional flat style</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatPanelControlRenderer.Render(Nuclex.UserInterface.Controls.Arcade.PanelControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatPanelControlRendererTest">
            <summary>Unit Test for the flat panel control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatPanelControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatPanelControlRendererTest.TestRenderNormal">
            <summary>Verifies that the renderer is able to render the panel</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatPanelControlRendererTest.renderer">
            <summary>Panel renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatPanelControlRendererTest.panel">
            <summary>Panel used to test the panel renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatProgressControlRenderer">
            <summary>Renders progress bars in a traditional flat style</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatProgressControlRenderer.Render(Nuclex.UserInterface.Controls.ProgressControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatProgressControlRendererTest">
            <summary>Unit Test for the flat progress bar control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatProgressControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatProgressControlRendererTest.TestRenderNormal">
            <summary>Verifies that the renderer is able to render the progress bar</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatProgressControlRendererTest.renderer">
            <summary>Progress bar renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatProgressControlRendererTest.progress">
            <summary>Progress bar used to test the progress bar renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVerticalSliderControlRenderer">
            <summary>Renders sliders in a traditional flat style</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVerticalSliderControlRenderer.Render(Nuclex.UserInterface.Controls.Desktop.VerticalSliderControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRenderer">
            <summary>Renders text input controls in a traditional flat style</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRenderer.Style">
            <summary>Style from the skin this renderer uses</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRenderer.Render(Nuclex.UserInterface.Controls.Desktop.InputControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRenderer.GetClosestOpening(Nuclex.UserInterface.RectangleF,System.String,Microsoft.Xna.Framework.Vector2)">
            <summary>
              Calculates which opening between two letters is closest to a position
            </summary>
            <param name="bounds">
              Boundaries of the control, should be in absolute coordinates
            </param>
            <param name="text">Text in which the opening will be looked for</param>
            <param name="position">
              Position to which the closest opening will be found,
              should be in absolute coordinates
            </param>
            <returns>The index of the opening closest to the provided position</returns>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatInputControlRenderer.graphics">
            <summary>Graphics interface we used for the last draw call</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVertialSliderControlRendererTest">
            <summary>Unit Test for the flat vertical slider control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVertialSliderControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVertialSliderControlRendererTest.TestRenderNormal">
            <summary>
              Verifies that the slider renderer can render normal sliders
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVertialSliderControlRendererTest.TestRenderHighlighted">
            <summary>
              Verifies that the slider renderer can render highlighted sliders
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVertialSliderControlRendererTest.TestRenderDepressed">
            <summary>
              Verifies that the slider renderer can render depressed sliders
            </summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVertialSliderControlRendererTest.drawAndExpectState(System.String)">
            <summary>
              Lets the renderer draw the slider and verifies that the slider used
              the skin elements from the expected state
            </summary>
            <param name="expectedState">
              Expected state the skin elements should be using
            </param>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVertialSliderControlRendererTest.renderer">
            <summary>Slider renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatVertialSliderControlRendererTest.slider">
            <summary>Slider used to test the slider renderer</summary>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatWindowControlRenderer">
            <summary>Renders window controls in a traditional flat style</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatWindowControlRenderer.Render(Nuclex.UserInterface.Controls.Desktop.WindowControl,Nuclex.UserInterface.Visuals.Flat.IFlatGuiGraphics)">
            <summary>
              Renders the specified control using the provided graphics interface
            </summary>
            <param name="control">Control that will be rendered</param>
            <param name="graphics">
              Graphics interface that will be used to draw the control
            </param>
        </member>
        <member name="T:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatWindowControlRendererTest">
            <summary>Unit Test for the flat window control renderer</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatWindowControlRendererTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatWindowControlRendererTest.TestRenderNormal">
            <summary>Verifies that the renderer is able to render the window</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatWindowControlRendererTest.renderer">
            <summary>Window renderer being tested</summary>
        </member>
        <member name="F:Nuclex.UserInterface.Visuals.Flat.Renderers.FlatWindowControlRendererTest.window">
            <summary>Window used to test the window renderer</summary>
        </member>
    </members>
</doc>
