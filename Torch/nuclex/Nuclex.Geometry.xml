<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nuclex.Geometry</name>
    </assembly>
    <members>
        <member name="T:Nuclex.Geometry.Areas.AxisAlignedRectangle2">
            <summary>Two-dimensional axis aligned rectangle</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.IArea2">
            <summary>Two-dimensional geometric body in 2D space</summary>
            <remarks>
              An area by definition and of course also in the context of this library is a
              two-dimensional region. This region could a either be located in actual
              2D space (like drawn on a piece of paper) or be located in as a flat object
              in 3D space (like the piece of paper located in the real world). This
              class represents the first case, a 2D object in 2D space.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea2.ClosestPointTo(Microsoft.Xna.Framework.Vector2)">
            <summary>Locates the nearest point in the shape to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the shape to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea2.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea2.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="P:Nuclex.Geometry.Areas.IArea2.Area">
            <summary>Surface area that the shape contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.IArea2.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.IArea2.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.IArea2.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Initializes the axis aligned rectangle</summary>
            <param name="min">Lower left bounds of the rectangle</param>
            <param name="max">Upper right bounds of the rectangle</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2.ClosestPointTo(Microsoft.Xna.Framework.Vector2)">
            <summary>Locates the nearest point in the area to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the area to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="F:Nuclex.Geometry.Areas.AxisAlignedRectangle2.Min">
            <summary>Top left bounds of the box</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.AxisAlignedRectangle2.Max">
            <summary>Bottom right bounds of the box</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.AxisAlignedRectangle2.Width">
            <summary>The width of the rectangle</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.AxisAlignedRectangle2.Height">
            <summary>The height of the rectangle</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.AxisAlignedRectangle2.Area">
            <summary>Surface area that the shape contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.AxisAlignedRectangle2.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.AxisAlignedRectangle2.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.AxisAlignedRectangle2.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.AxisAlignedRectangle2Test">
            <summary>Test for the two-dimensional axis aligned box implementation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2Test.TestFullConstructor">
            <summary>Tests whether the full constructor is working</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2Test.TestArea">
            <summary>
              Validates that the surface area of an axis aligned box can be calculated
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2Test.TestCircumferenceLength">
            <summary>
              Validates that the circumference length of an axis aligned box can be calculated
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2Test.TestCenterOfMass">
            <summary>
              Tests whether the center of mass for the rectangle is correctly calculated
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2Test.TestBoundingBox">
            <summary>
              Validates that the bounding box determination works for the rectangle
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2Test.TestClosestPointTo">
            <summary>
              Verifies that the closest point finder is working
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2Test.TestRandomPointOnPerimeter">
            <summary>
              Verifies that random points on the rectangle's perimeter can be calculated
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.AxisAlignedRectangle2Test.TestRandomPointWithin">
            <summary>
              Verifies that the closest point finder is working
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Collisions.AabbAabbCollider">
            <summary>Contains all Aabb-to-Aabb interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.AabbAabbCollider.CheckContact(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Test whether two axis aligned boxes are overlapping</summary>
            <param name="firstMin">Minimum coordinate of first box</param>
            <param name="firstMax">Maximum coordinate of first box</param>
            <param name="secondMin">Minimum coordinate of second box</param>
            <param name="secondMax">Maximum coordinate of second box</param>
            <returns>True if the boxes are intersecting each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.AabbAabbCollider.FindContact(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Find the contact location between two axis aligned boxes</summary>
            <param name="firstMin">Minimum coordinate of first box</param>
            <param name="firstMax">Maximum coordinate of first box</param>
            <param name="secondMin">Minimum coordinate of second box</param>
            <param name="secondMax">Maximum coordinate of second box</param>
            <returns>A contact location if the boxes touch each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.AabbAabbCollider.CheckContact(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Determines whether a box will hit another box</summary>
            <param name="firstMin">Minimum coordinate of first box</param>
            <param name="firstMax">Maximum coordinate of first box</param>
            <param name="secondMin">Minimum coordinate of second box</param>
            <param name="secondMax">Maximum coordinate of second box</param>
            <param name="secondVelocity">
              Velocity with which the second box is moving relative to the first box
            </param>
            <returns>True if the second box will hit the first box</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.AabbAabbCollider.FindContact(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Determines the time when the box will hit another box</summary>
            <param name="firstMin">Minimum coordinate of first box</param>
            <param name="firstMax">Maximum coordinate of first box</param>
            <param name="secondMin">Minimum coordinate of second box</param>
            <param name="secondMax">Maximum coordinate of second box</param>
            <param name="secondVelocity">
              Velocity with which the second box is moving relative to the first box
            </param>
            <returns>The point of first contact, if any</returns>
            <remarks>
              <para>
                Conventional tests that resort to stepping often fail to detect collisions
                between fast-moving objects. This impact determination test will always
                detect a collision if it occurs, giving the exact time of the impact.
              </para>
              <para>
                This is a simplified test that assumes a linear trajectory and does
                not take object rotation into account. It is well suited to use on
                two bounding boxes in order to determine if a collision between the
                shapes contained is possible at all.
              </para>
              <para>
                Idea taken from the "Simple Intersection Tests for Games" article
                on gamasutra by Gomez.
              </para>
            </remarks>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Collisions.AabbAabbColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.AabbAabbColliderTest.TestCheckContact">
            <summary>Tests intersection checking with two static AABBs</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.AabbAabbColliderTest.TestFindDynamicContact">
            <summary>Tests intersection checking with moving AABBs</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Collisions.Disc2Disc2Collider">
            <summary>Contains all Disc2-to-Disc2 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.Disc2Disc2Collider.CheckContact(Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>Test whether two discs are overlapping</summary>
            <param name="firstCenter">Center of the first disc</param>
            <param name="firstRadius">Radius of the first disc</param>
            <param name="secondCenter">Center of the second disc</param>
            <param name="secondRadius">Radius of the second disc</param>
            <returns>True if the discs are intersecting each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.Disc2Disc2Collider.FindContact(Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>Find the contact location between two discs</summary>
            <param name="firstCenter">Center of the first disc</param>
            <param name="firstRadius">Radius of the first disc</param>
            <param name="secondCenter">Center of the second disc</param>
            <param name="secondRadius">Radius of the second disc</param>
            <returns>A contact location if the discs touch each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.Disc2Disc2Collider.CheckContact(Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>Determines whether a disc will hit another box</summary>
            <param name="firstCenter">Center of the first disc</param>
            <param name="firstRadius">Radius of the first disc</param>
            <param name="secondCenter">Center of the second disc</param>
            <param name="secondRadius">Radius of the second disc</param>
            <param name="secondVelocity">
              Velocity with which the second disc is moving relative to the first disc
            </param>
            <returns>True if the second disc will hit the first disc</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Collisions.Disc2Disc2Collider.FindContact(Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>Determines the time when a disc will hit another disc</summary>
            <param name="firstCenter">Center of the first disc</param>
            <param name="firstRadius">Radius of the first disc</param>
            <param name="secondCenter">Center of the second disc</param>
            <param name="secondRadius">Radius of the second disc</param>
            <param name="secondVelocity">
              Velocity with which the second disc is moving relative to the first disc
            </param>
            <returns>The point of first contact, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Collisions.Disc2Disc2ColliderTest">
            <summary>Test for the disc interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Disc2">
            <summary>A two-dimensional circle</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2.#ctor(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>Initializes a new circle</summary>
            <param name="center">The center of the circle</param>
            <param name="radius">Radius the circle will have</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2.ClosestPointTo(Microsoft.Xna.Framework.Vector2)">
            <summary>Locates the nearest point on the disc to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point on the disc to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Disc2.Center">
            <summary>The center of the disc</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Disc2.Radius">
            <summary>Radius of the disc</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Disc2.Area">
            <summary>Surface area that the shape contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Disc2.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Disc2.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Disc2.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Disc2Test">
            <summary>Test for the circle (2D sphere) implementation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2Test.TestConstructor">
            <summary>Verifies that the constructor of the disc class is working</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2Test.TestSurfaceArea">
            <summary>
              Verifies that the total surface area of a disc can be determined
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2Test.TestCircumferenceLength">
            <summary>
              Verifies that the circumference length of the disc can be determined
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2Test.TestCenterOfMass">
            <summary>Verifies that the center of mass is correctly determined</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2Test.TestBoundingBox">
            <summary>
              Tests whether a tight-fitting bounding box for a disc can be obtained
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2Test.TestClosestPointTo">
            <summary>
              Tests whether the closest point determination works for two-dimensional discs
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2Test.TestRandomPointOnPerimeter">
            <summary>
              Tests whether random points on the perimeter of two-dimensional discs can
              be obtained
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc2Test.TestRandomPointWithin">
            <summary>
              Tests whether random points on the perimeter of two-dimensional discs can
              be obtained
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Disc3">
            <summary>Flat disc situated in 3D space</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.IArea3">
            <summary>Two-dimensional geometric body in 3D space</summary>
            <remarks>
              An area by definition and of course also in the context of this library is a
              two-dimensional region. This region could a either be located in actual
              2D space (like drawn on a piece of paper) or be located in as a flat object
              in 3D space (like the piece of paper located in the real world). This
              class represents the latter case, a 2D object in 3D space.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the shape to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the shape to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea3.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="P:Nuclex.Geometry.Areas.IArea3.Area">
            <summary>Surface area that the shape contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.IArea3.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.IArea3.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.IArea3.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc3.#ctor(Microsoft.Xna.Framework.Matrix,System.Single)">
            <summary>Initializes a new flat disc in 3D space</summary>
            <param name="transform">
              Transformation matrix definining the disc's position and orientation
            </param>
            <param name="radius">Radius of the disc</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the shape to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the shape to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc3.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Disc3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Disc3.Transform">
            <summary>Contains the position, orientation and scale of the disc</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Disc3.Radius">
            <summary>Radius of the disc</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Disc3.Area">
            <summary>Surface area that the shape contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Disc3.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Disc3.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Disc3.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.ImpactPoint">
            <summary>Informations about the point of first contact between two bodies</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.ImpactPoint.Found">
            <summary>Whether a contact could be found at all</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.ImpactPoint.AbsoluteLocation">
            <summary>The absolute location where the contact occurs</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.ImpactPoint.Time">
            <summary>The time at which the contact occurs</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.IArea2Visitor">
            <summary>Base class for area visitors</summary>
            <remarks>
              See the visitor pattern. 
              <para>
                If you need to perform work on a area whose type you do not know, you could
                of course just create a set of if(area is ...) queries. However, you would
                have to manually track down all these queries should a future version of this
                library provide a new type of volume.
              </para>
              <para>
                Your other option is to create a special class that does your work which derives
                from this AreaVisitor class. It will elegantly resolve the area type by
                calling into the area (resolving the type via the vtable) which then calls
                the visitor's distinctive method for the exact kind of area. If a new area
                is introduced to the library, it will be added to the AreaVisitor class and
                your compiler will point out to you where you need to extend your code for the
                new kind of area because the abstract method will not yet be implemented there.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea2Visitor.Visit(Nuclex.Geometry.Areas.AxisAlignedRectangle2)">
            <summary>Visit an axis aligned rectangle</summary>
            <param name="rectangle">Axis aligned rectangle to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea2Visitor.Visit(Nuclex.Geometry.Areas.Rectangle2)">
            <summary>Visit a rectangle</summary>
            <param name="rectangle">Rectangle to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea2Visitor.Visit(Nuclex.Geometry.Areas.Triangle2)">
            <summary>Visit a triangle</summary>
            <param name="triangle">Triangle to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea2Visitor.Visit(Nuclex.Geometry.Areas.Disc2)">
            <summary>Visit a disc</summary>
            <param name="disc">Disc to visit</param>
        </member>
        <member name="T:Nuclex.Geometry.Areas.IArea3Visitor">
            <summary>Base class for area visitors</summary>
            <remarks>
              See the visitor pattern. 
              <para>
                If you need to perform work on a area whose type you do not know, you could
                of course just create a set of if(area is ...) queries. However, you would
                have to manually track down all these queries should a future version of this
                library provide a new type of volume.
              </para>
              <para>
                Your other option is to create a special class that does your work which derives
                from this AreaVisitor class. It will elegantly resolve the area type by
                calling into the area (resolving the type via the vtable) which then calls
                the visitor's distinctive method for the exact kind of area. If a new area
                is introduced to the library, it will be added to the AreaVisitor class and
                your compiler will point out to you where you need to extend your code for the
                new kind of area because the abstract method will not yet be implemented there.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea3Visitor.Visit(Nuclex.Geometry.Areas.Rectangle3)">
            <summary>Visit a rectangle</summary>
            <param name="rectangle">Rectangle to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea3Visitor.Visit(Nuclex.Geometry.Areas.Triangle3)">
            <summary>Visit a triangle</summary>
            <param name="triangle">Triangle to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.IArea3Visitor.Visit(Nuclex.Geometry.Areas.Disc3)">
            <summary>Visit a disc</summary>
            <param name="disc">Disc to visit</param>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Plane3">
            <summary>Two-dimensional Plane</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Initializes a new Plane</summary>
            <param name="offset">Offset of the plane from the coordinate system's center</param>
            <param name="normal">Vector that is exactly perpendicular to the plane</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3.#ctor(System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>Initializes a new Plane</summary>
            <param name="distance">Distance of the plane from the coordinate system's center</param>
            <param name="normal">Vector that is exactly perpendicular to the plane</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3.GetSide(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines which side of a plane a point is on</summary>
            <param name="planeOffset">Offset of the plane</param>
            <param name="planeNormal">Normal vector of the plane</param>
            <param name="point">Location of the point to be checked</param>
            <returns>Which side of the plane the point is on</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the shape to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the shape to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Plane3.Offset">
            <summary>Offset of the plane from the coordinate system's center</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Plane3.Normal">
            <summary>Direction that is exactly perpendicular to the plane</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Plane3.Area">
            <summary>Surface area that the shape contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Plane3.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Plane3.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Plane3.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Plane3Test">
            <summary>Test for the three-dimensional plane implementation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestOffsetConstructor">
            <summary>Verifies that the constructor accepting an offset is working</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestDistanceConstructor">
            <summary>Verifies that the surface area of a plane is infinite</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestAreaIsInfinite">
            <summary>Verifies that the surface area of a plane is infinite</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestCircumferenceIsInfinite">
            <summary>Verifies that the circumference of a plane is infinite</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestCenterOfMass">
            <summary>Validates that a plane's center of mass can be calculated</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestSideDetermination">
            <summary>
              Validates that a plane's side determination helper is working as expected
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestBoundingBoxCalculationForXPlane">
            <summary>
              Verifies that the bounding box calculation of the plane class is working
              for planes perfectly aligned to the Y/Z axes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestBoundingBoxCalculationForYPlane">
            <summary>
              Verifies that the bounding box calculation of the plane class is working
              for planes perfectly aligned to the X/Z axes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestBoundingBoxCalculationForZPlane">
            <summary>
              Verifies that the bounding box calculation of the plane class is working
              for planes perfectly aligned to the X/Y axes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestBoundingBoxCalculation">
            <summary>
              Verifies that the bounding box calculation of the plane class is working
              for planes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestClosestPointToPlane">
            <summary>
              Tests whether the plane class is able to locate the closest point on the plane
              to an arbitrary point
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestRandomPointOnPerimeterForXPlane">
            <summary>
              Tests whether the plane class can find a random point on the plane's perimeter
              for a plane perfectly aligned to the Y/Z axes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestRandomPointOnPerimeterForYPlane">
            <summary>
              Tests whether the plane class can find a random point on the plane's perimeter
              for a plane perfectly aligned to the X/Z axes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestRandomPointOnPerimeterForZPlane">
            <summary>
              Tests whether the plane class can find a random point on the plane's perimeter
              for a plane perfectly aligned to the X/Y axes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestRandomPointOnPerimeter">
            <summary>
              Tests whether the plane class can find a random point on the plane's perimeter
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestRandomPointWithinForXPlane">
            <summary>
              Tests whether the plane class can find a random point within the plane
              for a plane perfectly aligned to the Y/Z axes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestRandomPointWithinForYPlane">
            <summary>
              Tests whether the plane class can find a random point within the plane
              for a plane perfectly aligned to the X/Z axes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestRandomPointWithinForZPlane">
            <summary>
              Tests whether the plane class can find a random point within the plane
              for a plane perfectly aligned to the X/Y axes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestRandomPointWithin">
            <summary>
              Tests whether the plane class can find a random point within the plane
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.TestThrowOnRandomPointOnPerimeterWithBrokenRandom">
            <summary>
              Tests whether the plane class throws an exception if the random number generator
              is malfunctioning (talk about edge cases...)
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Plane3Test.BrokenRandom">
            <summary>A broken random number generator</summary>
        </member>
        <member name="T:Nuclex.Geometry.IRandom">
            <summary>Interface for a random number generator</summary>
        </member>
        <member name="M:Nuclex.Geometry.IRandom.Next(System.Int32)">
            <summary>
              Returns a nonnegative random number less than the specified maximum
            </summary>
            <param name="maximumValue">
              The exclusive upper bound of the random number to be generated. maxValue must
              be greater than or equal to zero
            </param>
            <returns>
              A 32-bit signed integer greater than or equal to zero, and less than maxValue;
              that is, the range of return values ordinarily includes zero but not maxValue.
              However, if maxValue equals zero, maxValue is returned
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              maximumValue is less than zero
            </exception>
        </member>
        <member name="M:Nuclex.Geometry.IRandom.NextDouble">
            <summary>Returns a random number between 0.0 and 1.0</summary>
            <returns>
              A double-precision floating point number greater than or equal to 0.0,
              and less than 1.0
            </returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.BrokenRandom.Next(System.Int32)">
            <summary>
              Returns a nonnegative random number less than the specified maximum
            </summary>
            <param name="maximumValue">
              The exclusive upper bound of the random number to be generated. maxValue must
              be greater than or equal to zero
            </param>
            <returns>
              A 32-bit signed integer greater than or equal to zero, and less than maxValue;
              that is, the range of return values ordinarily includes zero but not maxValue.
              However, if maxValue equals zero, maxValue is returned
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              maximumValue is less than zero
            </exception>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Plane3Test.BrokenRandom.NextDouble">
            <summary>Returns a random number between 0.0 and 1.0</summary>
            <returns>
              A double-precision floating point number greater than or equal to 0.0,
              and less than 1.0
            </returns>
        </member>
        <member name="T:Nuclex.Geometry.Areas.PointGenerators.Disc2PointGenerator">
            <summary>Point generator for disc areas</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Disc2PointGenerator.GenerateRandomPointOnPerimeter(Nuclex.Geometry.IRandom,System.Single)">
            <summary>Returns a random point on the perimeter of a disc</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="radius">Radius of the disc</param>
            <returns>A random point on the disc's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Disc2PointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,System.Single)">
            <summary>Returns a random point within a disc</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="radius">Radius of the disc</param>
            <returns>A random point within the disc</returns>
        </member>
        <member name="T:Nuclex.Geometry.Areas.PointGenerators.Disc3PointGenerator">
            <summary>Point generator for disc areas</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Disc3PointGenerator.GenerateRandomPointOnPerimeter(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Matrix,System.Single)">
            <summary>Returns a random point on the perimeter of a disc</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="orientation">Orientation of the disc in space</param>
            <param name="radius">Radius of the disc</param>
            <returns>A random point on the disc's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Disc3PointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Matrix,System.Single)">
            <summary>Returns a random point within a disc</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="orientation">Orientation of the disc in space</param>
            <param name="radius">Radius of the disc</param>
            <returns>A random point within the disc</returns>
        </member>
        <member name="T:Nuclex.Geometry.Areas.PointGenerators.Plane3PointGenerator">
            <summary>Point generator for planes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Plane3PointGenerator.RandomPointOnPerimeter(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a random point on a plane's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="normal">Normal of the plane around which to create a random point</param>
            <returns>A random point on the plane's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Plane3PointGenerator.RandomPointWithin(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a random point within a plane</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="normal">Normal of the plane in which to create a random point</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Plane3PointGenerator.generateRandomPlanePoint(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a random point around or within the plane</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="normal">Normal of the plane</param>
            <returns>A random point around or within the plane</returns>
            <remarks>
              <para>
                Since the plane extends to infinity in each direction, the chance of hitting
                a value outside of what can be expressed with a meager float (and actually,
                any finite numbering system) is infinitely larger than being within the range
                we can express, so we can assume the chance of the result being infinity is
                about 1.
              </para>
              <para>
                The same applies to both, finding a point on the plane's perimeter as well as
                finding a point within the plane, so this method is used for both cases.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Plane3PointGenerator.infinitize(System.Single)">
            <summary>Scales any value but zero to positive or negative infinity</summary>
            <param name="value">Value that will be scaled to infinity if not zero</param>
            <returns>The input value scaled to infinity if it wasn't zero</returns>
        </member>
        <member name="T:Nuclex.Geometry.Areas.PointGenerators.Rectangle2PointGenerator">
            <summary>Point generator for rectangle areas</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Rectangle2PointGenerator.GenerateRandomPointOnPerimeter(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Returns a random point on the perimeter of a rectangle</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="min">Lower left coordinate of the rectangle</param>
            <param name="max">Upper right coordinate of the rectangle</param>
            <returns>A random point on the rectangle's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Rectangle2PointGenerator.GenerateRandomPointOnPerimeter(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector2)">
            <summary>Returns a random point on the perimeter of a rectangle</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="extents">Extents of the rectangle</param>
            <returns>A random point on the rectangle's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Rectangle2PointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector2)">
            <summary>Returns a random point within a rectangle</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="extents">Extents of the rectangle</param>
            <returns>A random point within the rectangle</returns>
        </member>
        <member name="T:Nuclex.Geometry.Areas.PointGenerators.Rectangle3PointGenerator">
            <summary>Point generator for rectangle areas</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Rectangle3PointGenerator.GenerateRandomPointOnPerimeter(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector2)">
            <summary>Returns a random point on the perimeter of a rectangle</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="orientation">Orientation of the rectangle in space</param>
            <param name="extents">Extents of the rectangle</param>
            <returns>A random point on the rectangle's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Rectangle3PointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector2)">
            <summary>Returns a random point within a rectangle</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="orientation">Orientation of the rectangle in space</param>
            <param name="extents">Extents of the rectangle</param>
            <returns>A random point within the rectangle</returns>
        </member>
        <member name="T:Nuclex.Geometry.Areas.PointGenerators.Triangle2PointGenerator">
            <summary>Point generator for triangle areas</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Triangle2PointGenerator.GenerateRandomPointOnPerimeter(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Returns a random point on the perimeter of a triangle</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="a">Location of the triangle's first corner</param>
            <param name="b">Location of the triangle's second corner</param>
            <param name="c">Location of the triangle's third corner</param>
            <returns>A random point on the triangle's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Triangle2PointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Returns a random point within a triangle</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="a">Location of the triangle's first corner</param>
            <param name="b">Location of the triangle's second corner</param>
            <param name="c">Location of the triangle's third corner</param>
            <returns>A random point within the triangle</returns>
        </member>
        <member name="T:Nuclex.Geometry.Areas.PointGenerators.Triangle3PointGenerator">
            <summary>Point generator for triangle areas</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Triangle3PointGenerator.GenerateRandomPointOnPerimeter(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a random point on the perimeter of a triangle</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="a">Location of the triangle's first corner</param>
            <param name="b">Location of the triangle's second corner</param>
            <param name="c">Location of the triangle's third corner</param>
            <returns>A random point on the triangle's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.PointGenerators.Triangle3PointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a random point within a triangle</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="a">Location of the triangle's first corner</param>
            <param name="b">Location of the triangle's second corner</param>
            <param name="c">Location of the triangle's third corner</param>
            <returns>A random point within the triangle</returns>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Rectangle2">
            <summary>Two-dimensional box with arbitrary orientation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Rectangle2.ClosestPointTo(Microsoft.Xna.Framework.Vector2)">
            <summary>Locates the nearest point in the area to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the area to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Rectangle2.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Rectangle2.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Rectangle2.Transform">
            <summary>Orientation, position and scale of the rectangle</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle2.Area">
            <summary>Surface area that the shape contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle2.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle2.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle2.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle2.Width">
            <summary>Width of the rectangle</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle2.Height">
            <summary>Height of the rectangle</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Rectangle2Test">
            <summary>Test for the two-dimensional box implementation</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Rectangle3">
            <summary>Flat rectangle situated in 3D space</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Rectangle3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the shape to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the shape to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Rectangle3.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Rectangle3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle3.Area">
            <summary>Surface area that the shape contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle3.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle3.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Rectangle3.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Triangle2">
            <summary>Two-dimensional triangle</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle2.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Initializes a new triangle</summary>
            <param name="a">First corner of the triangle</param>
            <param name="b">Second corner of the triangle</param>
            <param name="c">Third corner of the triangle</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle2.ClosestPointTo(Microsoft.Xna.Framework.Vector2)">
            <summary>Locates the nearest point on the triangle to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point on the triangle to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle2.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle2.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Triangle2.A">
            <summary>The three corner points of the triangle</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Triangle2.B">
            <summary>The three corner points of the triangle</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Triangle2.C">
            <summary>The three corner points of the triangle</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Triangle2.Area">
             <summary>Surface area that the shape contains</summary>
             <remarks>
               <para>
                 Heron's triangle area formular states that, given s = (a + b + c) / s the
                 area of a triangle can be calculated as
               </para>
               <code>
                          _________________________________
                 area = \/ s * (s - a) * (s - b) * (s - c)   
            
               </code>
               <para>
                 In a paper by W. Kahan this method is proven to be numerically unstable
                 for floating point numbers. He recommends to use the following formula
                 instead, where the lengths a, b and c have to be sorted in ascending order.
               </para>
               <code>
                                 ______________________________________________________________
                 area = 0.25 * \/ (a + (b + c)) * (c - (a - b)) * (c + (a - b)) * (a + b - c))
            
               </code>
             </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Triangle2.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Triangle2.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Triangle2.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Triangle2.IsClockwiseTriangle">
            <summary>Determines whether the triangle's points are in clockwise order</summary>
            <remarks>
              This method assumes a normal cartesian coordinate system with the X axis
              extending to the right and the Y axis extending upwards.
            </remarks>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Triangle2Test">
            <summary>Test for the two-dimensional triangle implementation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle2Test.TestMassProperties">
            <summary>Tests whether the mass properties of the volume are working</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Triangle3">
            <summary>Three-dimensional triangle</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle3.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Initializes a new triangle</summary>
            <param name="a">First corner of the triangle</param>
            <param name="b">Second corner of the triangle</param>
            <param name="c">Third corner of the triangle</param>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the shape to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the shape to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle3.RandomPointOnPerimeter(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the area's perimeter</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the area's perimeter</returns>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point inside the area</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point inside the area</returns>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Triangle3.A">
            <summary>The three corner points of the triangle</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Triangle3.B">
            <summary>The three corner points of the triangle</summary>
        </member>
        <member name="F:Nuclex.Geometry.Areas.Triangle3.C">
            <summary>The three corner points of the triangle</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Triangle3.Area">
             <summary>Surface area that the shape contains</summary>
             <remarks>
               <para>
                 Heron's triangle area formular states that, given s = (a + b + c) / s the
                 area of a triangle can be calculated as
               </para>
               <code>
                          _________________________________
                 area = \/ s * (s - a) * (s - b) * (s - c)   
            
               </code>
               <para>
                 In a paper by W. Kahan this method is proven to be numerically unstable
                 for floating point numbers. He recommends to use the following formula
                 instead, where the lengths a, b and c have to be sorted in ascending order.
               </para>
               <code>
                                 ______________________________________________________________
                 area = 0.25 * \/ (a + (b + c)) * (c - (a - b)) * (c + (a - b)) * (a + b - c))
            
               </code>
             </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Triangle3.CircumferenceLength">
            <summary>The total length of the area's circumference</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Triangle3.CenterOfMass">
            <summary>The center of mass within the shape</summary>
        </member>
        <member name="P:Nuclex.Geometry.Areas.Triangle3.BoundingBox">
            <summary>Smallest rectangle that encloses the shape in its entirety</summary>
        </member>
        <member name="T:Nuclex.Geometry.Areas.Triangle3Test">
            <summary>Test for the three-dimensional triangle implementation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Areas.Triangle3Test.TestMassProperties">
            <summary>Tests whether the mass properties of the volume are working</summary>
        </member>
        <member name="T:Nuclex.Geometry.GeoAssertHelperTest">
            <summary>Unit Test for the NUnit assertion helper</summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.TestAlmostEqualWithVectors">
            <summary>Tests whether the almost equal check works with vectors</summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.TestThrowOnAlmostEqualWithTooLowXInVector">
            <summary>
              Tests whether the almost equal check detects an X component in a vector that
              is just barely too low
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.TestThrowOnAlmostEqualWithTooHighXInVector">
            <summary>
              Tests whether the almost equal check detects an X component in a vector that
              is just barely too high
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.TestThrowOnAlmostEqualWithTooLowYInVector">
            <summary>
              Tests whether the almost equal check detects an Y component in a vector that
              is just barely too low
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.TestThrowOnAlmostEqualWithTooHighYInVector">
            <summary>
              Tests whether the almost equal check detects an Y component in a vector that
              is just barely too high
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.TestThrowOnAlmostEqualWithTooLowZInVector">
            <summary>
              Tests whether the almost equal check detects an Z component in a vector that
              is just barely too low
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.TestThrowOnAlmostEqualWithTooHighZInVector">
            <summary>
              Tests whether the almost equal check detects an Z component in a vector that
              is just barely too high
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.TestAlmostEqualWithAxisAlignedBoxes">
            <summary>
              Verifies that the AreAlmostEqual() helper works correctly when comparing
              two axis aligned boxes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.TestThrowOnAlmostEqualWithTooLargeAxisAlignedBox">
            <summary>
              Verifies that the AreAlmostEqual() helper throws an exception when the compared
              boxes differ by more than the allowed amount
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.adjust(System.Single,System.Int32)">
            <summary>
              Adjusts a floating point value by the specified amount of neighbouring
              representable values
            </summary>
            <param name="value">Floating point value to be adjusted</param>
            <param name="ulps">Numbers of neighbouring representable values to step</param>
            <returns>The adjusted floating point value</returns>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelperTest.adjust(System.Double,System.Int64)">
            <summary>
              Adjusts a double precision floating point value by the specified amount of
              neighbouring representable values
            </summary>
            <param name="value">Double precision floating point value to be adjusted</param>
            <param name="ulps">Numbers of neighbouring representable values to step</param>
            <returns>The adjusted double precision floating point value</returns>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.exactFloat">
            <summary>The exact test value as a float</summary>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.minusTwoFloat">
            <summary>The second next possible smaller float from the test value</summary>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.minusOneFloat">
            <summary>The next possible smaller float from the test value</summary>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.plusOneFloat">
            <summary>The next possible greater float from the test value</summary>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.plusTwoFloat">
            <summary>The second next possible greater float from the test value</summary>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.exactDouble">
            <summary>The exact test value as a float</summary>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.minusTwoDouble">
            <summary>The second next possible smaller float from the test value</summary>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.minusOneDouble">
            <summary>The next possible smaller float from the test value</summary>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.plusOneDouble">
            <summary>The next possible greater float from the test value</summary>
        </member>
        <member name="F:Nuclex.Geometry.GeoAssertHelperTest.plusTwoDouble">
            <summary>The second next possible greater float from the test value</summary>
        </member>
        <member name="T:Nuclex.Geometry.DefaultRandom">
            <summary>
              Default random number generator wrapping the built-in .NET one
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.DefaultRandom.#ctor">
            <summary>
              Initializes a new random number generator, using a time-dependent seed value
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.DefaultRandom.#ctor(System.Int32)">
            <summary>
              Initializes a new random number generator, using the specified seed value
            </summary>
            <param name="seed">
              A number used to calculate a starting value for the pseudo-random number
              sequence. If a negative number is specified, the absolute value of
              the number is used.
            </param>
            <exception cref="T:System.OverflowException">
              Seed is System.Int32.MinValue, which causes an overflow when its absolute
              value is calculated
            </exception>
        </member>
        <member name="M:Nuclex.Geometry.DefaultRandom.Next(System.Int32)">
            <summary>
              Returns a nonnegative random number less than the specified maximum
            </summary>
            <param name="maximumValue">
              The exclusive upper bound of the random number to be generated. maxValue must
              be greater than or equal to zero
            </param>
            <returns>
              A 32-bit signed integer greater than or equal to zero, and less than maxValue;
              that is, the range of return values ordinarily includes zero but not maxValue.
              However, if maxValue equals zero, maxValue is returned
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              maximumValue is less than zero
            </exception>
        </member>
        <member name="M:Nuclex.Geometry.DefaultRandom.NextDouble">
            <summary>Returns a random number between 0.0 and 1.0</summary>
            <returns>
              A double-precision floating point number greater than or equal to 0.0,
              and less than 1.0
            </returns>
        </member>
        <member name="F:Nuclex.Geometry.DefaultRandom.random">
            <summary>The .NET random number generator being wrapped</summary>
        </member>
        <member name="T:Nuclex.Geometry.DefaultRandomTest">
            <summary>Unit Test for the default random number generator</summary>
        </member>
        <member name="M:Nuclex.Geometry.DefaultRandomTest.TestDefaultConstructor">
            <summary>Verifies that the default constructor works</summary>
        </member>
        <member name="M:Nuclex.Geometry.DefaultRandomTest.TestSeedConstructor">
            <summary>Verifies that the constructor with explicit seed value works</summary>
        </member>
        <member name="M:Nuclex.Geometry.DefaultRandomTest.TestReseed">
            <summary>Verifies that the seed value has the desired effect</summary>
        </member>
        <member name="M:Nuclex.Geometry.DefaultRandomTest.TestNext">
            <summary>
              Verifies that the random number generator can generate integers within a range
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.DefaultRandomTest.TestNextDouble">
            <summary>
              Verifies that the random number generator can generate doubles within a range
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Side">
            <summary>Sides of a plane in 3D space</summary>
        </member>
        <member name="F:Nuclex.Geometry.Side.Negative">
            <summary>Negative half space (away from the plane's normal vector)</summary>
        </member>
        <member name="F:Nuclex.Geometry.Side.Positive">
            <summary>Positive half space (same side as the plane's normal vector)</summary>
        </member>
        <member name="T:Nuclex.Geometry.Specifications">
            <summary>Targetted specifications of the library</summary>
        </member>
        <member name="F:Nuclex.Geometry.Specifications.MaximumDeviation">
            <summary>Maximum allowed deviation from perfect accuracy</summary>
            <remarks>
              This value indicates the maximum error that may be introduced with any given
              calculation. If it is exceeded, the algorithm that produced the result should
              be checked for numerical stability.
            </remarks>
        </member>
        <member name="F:Nuclex.Geometry.Specifications.HullAccuracy">
            <summary>Distance where intersection tests do not give stable results</summary>
            <remarks>
              If two geometrical objects are very close to each other, floating point
              inaccuracies can lead to unstable results for intersection tests. This value
              indicates how close two objects need to be for this to occur.
            </remarks>
        </member>
        <member name="F:Nuclex.Geometry.Specifications.ProbabilisticFunctionSamples">
            <summary>Number of samples used to unit-test probabilistic functions</summary>
            <remarks>
              Some functions are intended to return randomness, like all variants of the
              RandomPointOnSurface() method for geometric volumes. To unit-test these
              functions, the best way is to generate a large number of random samples and
              then see if certain criteria of these points are met (containment, average
              value and more).
            </remarks>
        </member>
        <member name="F:Nuclex.Geometry.Specifications.ProbabilisticFunctionDeviation">
            <summary>Deviation allowed for probabilistic function unit tests</summary>
            <remarks>
              Acceptable deviation of the averaged samples from the perfect median value.
              The more samples you run, the less deviation occurs.
            </remarks>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line2Aabb2Collider">
            <summary>
              Detects intersections of infinite 2D lines with 2D axis-aligned boxes
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Aabb2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Determines the contact times of a line with an axis aligned box</summary>
            <param name="lineOffset">Offset of the line from the box</param>
            <param name="lineDirection">Direction into which the line goes</param>
            <param name="boxExtents">Extents of the box (half of the box' dimensions)</param>
            <returns>The contact points, if any, between the line and the box</returns>
            <remarks>
              Shamelessly lifted from the FreeMagic library at http://www.magic-software.com
              and used as a supporting function for the other line/box contact finders.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Aabb2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Determines the contact times of a line with an axis aligned box</summary>
            <param name="lineOffset">Offset of the line from the box</param>
            <param name="lineDirection">Direction into which the line goes</param>
            <param name="minBoxCorner">Corner of the box with the lesser coordinates</param>
            <param name="maxBoxCorner">Corner of the box with the greater coordinates</param>
            <returns>The contact points, if any, between the line and the box</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Aabb2Collider.clip(System.Single,System.Single,System.Single@,System.Single@)">
            <summary>Determines where a line will intersect with a normalized plane</summary>
            <param name="denominator">Denominator of the line's direction towards the plane</param>
            <param name="numerator">Numerator of the line's direction towards the plane</param>
            <param name="entryTime">Time of entry into the plane</param>
            <param name="exitTime">Time of exit from the plane</param>
            <returns>True if the line segment actually intersects with the plane</returns>
            <remarks>
              Shamelessly lifted from the FreeMagic library at http://www.magic-software.com
              and used as a supporting function for the other line/box contact finders.
            </remarks>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line2Aabb2ColliderTest">
            <summary>
              Unit test for the 2D line vs. 2D axis-aligned bounding box interference detector
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Aabb2ColliderTest.TestCloseMiss">
            <summary>
              Tests whether a close miss of the box results in no contacts being reported
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Aabb2ColliderTest.TestDiagonalCloseMiss">
            <summary>
              Tests whether a close miss of the box with a diagonal line results in
              no contacts being reported
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Aabb2ColliderTest.TestContact">
            <summary>Tests whether a contact with a box is reported correctly</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Aabb2ColliderTest.TestContactOnCornerDefinedBox">
            <summary>
              Tests whether a contact with a box defined by two corner points can be detected
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line2Disc2Collider">
            <summary>
              Detects intersections of infinite 2D lines with 2D discs / circles
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Disc2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>Determines the contact location between a line and a disc</summary>
            <param name="lineOffset">
              Offset of the line relative to the disc's center
            </param>
            <param name="lineDirection">Direction and length of the line</param>
            <param name="discRadius">Radius of the disc</param>
            <returns>The point of intersection of the line with the disc, if any</returns>
            <remarks>
              <para>
                Shamelessly lifted from the FreeMagic library at http://www.magic-software.com
                and used as a supporting function for the other line/sphere contact finders.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Disc2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>Determines the contact location between a line and a disc</summary>
            <param name="lineOffset">
              Offset of the line from the coordinate system's center
            </param>
            <param name="lineDirection">Direction and length of the line</param>
            <param name="discCenter">Position of the disc </param>
            <param name="discRadius">Radius of the disc</param>
            <returns>The point of intersection of the line with the disc, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line2Disc2ColliderTest">
            <summary>Unit test for the 2D line vs. 2D disc interference detector</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Disc2ColliderTest.TestCloseMiss">
            <summary>
              Tests whether a close miss of a circle results in no contact being reported
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Disc2ColliderTest.TestLineThroughCenter">
            <summary>
              Tests whether a line crossing the center of a disc generates the appropriate
              contact intervals.
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Disc2ColliderTest.TestCircleWithAbsolutePosition">
            <summary>
              Tests whether a line crossing the center of a disc generates the appropriate
              contact intervals.
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line2Line2Collider">
            <summary>Detects intersections between two infinite 2D lines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Line2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Determines the point of contact between two infinite lines</summary>
            <param name="firstOffset">Offset of the first line</param>
            <param name="firstDirection">Direction into which the first line extends</param>
            <param name="secondOffset">Offset of the second line</param>
            <param name="secondDirection">Direction into which the second line extends</param>
            <returns>The relative position of the contact on the first line</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line2Line2ColliderTest">
            <summary>
              Unit test for the 2D infinite line vs. 2d infinite line interference detector
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Line2ColliderTest.TestHorizontalParallelLines">
            <summary>
              Ensures no collisions are reported between two horizontal parallel lines
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Line2ColliderTest.TestVerticalParallelLines">
            <summary>
              Ensures no collisions are reported between two vertical parallel lines
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Line2ColliderTest.TestOrthogonallyCrossingLines">
            <summary>
              Verifies that the intersection of two lines crossing each other
              orthogonally is detected
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Line2ColliderTest.TestDiagonallyCrossingLines">
            <summary>
              Verifies that the intersection of two lines crossing each other
              diagonally is detected
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line2Triangle2Collider">
            <summary>Detects intersections between infinite 2D lines and 2D triangles</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Triangle2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Determines the contact location between a line and a triangle</summary>
            <param name="lineOffset">
              Offset of the line from the coordinate system's center
            </param>
            <param name="lineDirection">Direction and length of the line</param>
            <param name="triangleA">
              First corner point of triangle in counter-clockwise order
            </param>
            <param name="triangleB">
              Second corner point of triangle in counter-clockwise order
            </param>
            <param name="triangleC">
              Third corner point of triangle in counter-clockwise order
            </param>
            <returns>The point of intersection of the line with the triangle, if any</returns>
            <remarks>
              Everyone seems to know how to do 3D line / triangle intersections, but there
              are no resources whatsoever on 2D line / triangle intersections. The code in here
              is hand-written by myself. Instead of fancy math tricks, it simply tries to be
              efficient using the existing code. It requires 4 line checks to find the accurate
              intersection point with the triangle.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Triangle2Collider.isWithin(Nuclex.Geometry.Lines.LineContacts,System.Single)">
            <summary>
              Finds out whether a reported contact point lies within a line segment
            </summary>
            <param name="contacts">Reported contact point that will be checked</param>
            <param name="length">
              Length of the line segment against which the test that created the contact
              point was made
            </param>
            <returns>True if the contact point is within the line segment</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line2Triangle2ColliderTest">
            <summary>
              Unit test for the 2D infinite line to 2D triangle interference detector
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Triangle2ColliderTest.TestCloseMiss">
            <summary>
              Tests whether a line that closely misses a triangle is detected as such
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Triangle2ColliderTest.TestHitLeftToRight">
            <summary>
              Tests whether the contact finder reports the correct locations for a line
              that crosses a triangle through its center from left to right
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Triangle2ColliderTest.TestHitRightToLeft">
            <summary>
              Tests whether the contact finder reports the correct locations for a line
              that crosses a triangle through its center from right to left
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Triangle2ColliderTest.TestHitTopToBottom">
            <summary>
              Tests whether the contact finder reports the correct locations for a line
              that crosses a triangle through its center from top to bottom
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Triangle2ColliderTest.TestHitBottomToTop">
            <summary>
              Tests whether the contact finder reports the correct locations for a line
              that crosses a triangle through its center from bottom to top
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Triangle2ColliderTest.TestHitRightToBottom">
            <summary>
              Tests whether the contact finder reports the correct locations for a line
              that crosses a triangle through its center from right to bottom
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line2Triangle2ColliderTest.TestHitBottomToRight">
            <summary>
              Tests whether the contact finder reports the correct locations for a line
              that crosses a triangle through its center from bottom to right
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line3Aabb3Collider">
            <summary>Contains all Line3 to Aabb3 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Aabb3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines the contact times of a line with an axis aligned box</summary>
            <param name="lineOffset">Offset of the line from the box</param>
            <param name="lineDirection">Direction into which the line goes</param>
            <param name="boxExtents">Extents of the box (half of the box' dimensions)</param>
            <returns>The contact points, if any, between the line and the box</returns>
            <remarks>
              Shamelessly lifted from the FreeMagic library at http://www.magic-software.com
              and used as a supporting function for the other line/box contact finders.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Aabb3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines the contact times of a line with an axis aligned box</summary>
            <param name="lineOffset">Offset of the line from the box</param>
            <param name="lineDirection">Direction into which the line goes</param>
            <param name="minBoxCorner">Corner of the box with the lesser coordinates</param>
            <param name="maxBoxCorner">Corner of the box with the greater coordinates</param>
            <returns>The contact points, if any, between the line and the box</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Aabb3Collider.clip(System.Single,System.Single,System.Single@,System.Single@)">
            <summary>Determines where a line will intersect with a normalized plane</summary>
            <param name="denominator">Denominator of the line's direction towards the plane</param>
            <param name="numerator">Numerator of the line's direction towards the plane</param>
            <param name="entryTime">Time of entry into the plane</param>
            <param name="exitTime">Time of exit from the plane</param>
            <returns>True if the line segment actually intersects with the plane</returns>
            <remarks>
              Shamelessly lifted from the FreeMagic library at http://www.magic-software.com
              and used as a supporting function for the other line/box contact finders.
            </remarks>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line3Aabb3ColliderTest">
            <summary>Test for the Line3 to Aabb3 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Aabb3ColliderTest.TestCloseMiss">
            <summary>
              Tests whether a close miss of the box results in no contacts being reported
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Aabb3ColliderTest.TestDiagonalCloseMiss">
            <summary>
              Tests whether a close miss of the box with a diagonal line results in
              no contacts being reported
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Aabb3ColliderTest.TestContact">
            <summary>Tests whether a contact with a box is reported correctly</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Aabb3ColliderTest.TestContactOnCornerDefinedBox">
            <summary>
              Tests whether a contact with a box defined by two corner points can be detected
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line3Plane3Collider">
            <summary>Contains all Line3 to Plane3 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Plane3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines where a line will hit a plane, if at all</summary>
            <param name="lineOffset">
              Offset of the line from the coordinate system's center
            </param>
            <param name="lineDirection">Direction and length of the line</param>
            <param name="planeOffset">
              Offset of the plane from the coordinate system's center
            </param>
            <param name="planeNormal">Normal vector of the plane</param>
            <returns>
              The intersection point between the line and the plane, if they touch
            </returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line3Plane3ColliderTest">
            <summary>Test for the Line3 to Plane3 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Plane3ColliderTest.TestParallelLineAbovePlane">
            <summary>
              Verifies that a line that is above and parallel to a plane does not
              register as a contact
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Plane3ColliderTest.TestParallelLineBelowPlane">
            <summary>
              Verifies that a line that is above and parallel to a plane does not
              register as a contact
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Plane3ColliderTest.TestLineCrossingPlaneOrthogonally">
            <summary>
              Tests whether a contact is detected for a line crossing a plane orthogonally
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Plane3ColliderTest.TestLineCrossingPlaneDiagonally">
            <summary>
              Tests whether a contact is detected for a line crossing a plane diagonally
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line3Sphere3Collider">
            <summary>Contains all Line3 to Sphere3 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Sphere3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Determines the points of contact between a line and a sphere</summary>
            <param name="lineOffset">
              Offset of the line from the coordinate system's center
            </param>
            <param name="lineDirection">Vector indicating the line's direction</param>
            <param name="sphereRadius">Radius of the sphere</param>
            <returns>
              The locations at which the line enters and leaves the sphere, if any
            </returns>
            <remarks>
              <para>
                This variant of the algorithm either returns two contacts or none. There is no
                special case for when the line exactly touches the circumference of the sphere,
                thus producing a single contact. This case will be handled as if no contact
                occured at all.
              </para>
              <para>
                Shamelessly lifted from the FreeMagic library at http://www.magic-software.com
                and used as a supporting function for the other line/sphere contact finders.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Sphere3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Determines the points of contact between a line and a sphere</summary>
            <param name="lineOffset">Offset of the line from the sphere's center</param>
            <param name="lineDirection">Vector indicating the line's direction</param>
            <param name="sphereCenter">
              Absolute coordinates of the sphere's center point
            </param>
            <param name="sphereRadius">Radius of the sphere</param>
            <returns>
              The locations at which the line enters and leaves the sphere, if any
            </returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line3Sphere3ColliderTest">
            <summary>Test for the Ray3 to Sphere3 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Sphere3ColliderTest.TestCloseMiss">
            <summary>
              Tests whether a line that is barely outside of the sphere is correctly
              identified as a non-hit
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Sphere3ColliderTest.TestCenterCrossing">
            <summary>
              Tests whether a line that crosses the sphere through its center causes
              to right contact points to be reported
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line3Triangle3Collider">
            <summary>Contains all Line3 to Triangle3 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Triangle3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines the contact location between a line and a triangle</summary>
            <param name="lineOffset">
              Offset of the line from the coordinate system's center
            </param>
            <param name="lineDirection">Direction of the line</param>
            <param name="triangleA">
              First corner point of triangle in counter-clockwise order
            </param>
            <param name="triangleB">
              Second corner point of triangle in counter-clockwise order
            </param>
            <param name="triangleC">
              Third corner point of triangle in counter-clockwise order
            </param>
            <returns>The point of intersection of the line with the triangle, if any</returns>
            <remarks>
              <para>
                I saw this algorithm in an article to line/triangle intersections tests
                by Christopher Bartlett. The material was stated to be free for learning
                purposes, so I felt free to apply what I've learned here =)
              </para>
              <para>
                There is no special case for when the line precisely touches one of
                the triangle's corners. It will either enter and exit the triangle or
                no contacts will be detected at all.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Triangle3Collider.isOnPositiveSide(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Tests whether a point is on the positive side of a line</summary>
            <param name="start">Starting point of the line</param>
            <param name="end">Ending point of the line</param>
            <param name="position">Position to check for the side it is on</param>
            <param name="normal">Normal vector of the plane the query takes place on</param>
            <returns>True if the point is on the positive side of the line</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Line3Triangle3ColliderTest">
            <summary>Test for the Line3 to Triangle3 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Triangle3ColliderTest.TestCloseMiss">
            <summary>
              Tests whether a line that closely misses a triangle is detected as such
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Line3Triangle3ColliderTest.TestHitThroughCenter">
            <summary>
              Tests whether the contact finder reports the correct locations for a line
              that crosses a triangle through its center 
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray2Aabb2Collider">
            <summary>Contains all Ray2 to Aabb2 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Aabb2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Determines where a ray will hit a box, if at all</summary>
            <param name="rayStart">Starting point of the ray</param>
            <param name="rayDirection">Direction into which the ray extends</param>
            <param name="boxExtents">Extents of the box</param>
            <returns>The intersection points between the ray and the box, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray2Aabb2ColliderTest">
            <summary>Test for the Ray2 to Aabb2 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Aabb2ColliderTest.TestRayStartingInside">
            <summary>Validates the proper behavior if the ray starts inside the box</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Aabb2ColliderTest.TestRayStartingBehind">
            <summary>Validates the proper behavior if the ray starts behind the box</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray2Disc2Collider">
            <summary>Contains all Ray2 to Disc2 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Disc2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>Determines where a ray will hit a disc, if at all</summary>
            <param name="rayStart">Starting point of the ray</param>
            <param name="rayDirection">Direction into which the ray extends</param>
            <param name="discRadius">Radius of the disc</param>
            <returns>The intersection points between the ray and the box, if any</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Disc2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>Determines where a ray will hit a disc, if at all</summary>
            <param name="rayStart">Starting point of the ray</param>
            <param name="rayDirection">Direction into which the ray extends</param>
            <param name="discCenter">Center of the disc</param>
            <param name="discRadius">Radius of the disc</param>
            <returns>The intersection points between the ray and the box, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray2Disc2ColliderTest">
            <summary>Unit test for the 2D ray vs. 2D disc interference detector</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Disc2ColliderTest.TestRayStartingInside">
            <summary>
              Verifies that the right contacts are returned for a ray that starts
              inside of the disc
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Disc2ColliderTest.TestRayStartingBehind">
            <summary>
              Verifies that no contacts are returned for a ray whose starting point
              lies behind the disc
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Disc2ColliderTest.TestRayStartingInsideWithAbsoluteDiscPosition">
            <summary>
              Verifies that a ray starting inside an absolutely positioned disc is
              correctly handled by the intersection detector
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Disc2ColliderTest.TestRayStartingBehindWithAbsoluteDiscPosition">
            <summary>
              Verifies that a ray starting behind an absolutely positioned disc causes
              no contacts to be returned by the intersection detector
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray2Line2Collider">
            <summary>Contains all Ray2 to Line2 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Line2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Determines where a ray will hit a line, if at all</summary>
            <param name="rayStart">Starting point of the ray</param>
            <param name="rayDirection">Direction into which the ray extends</param>
            <param name="lineOffset">Offset of the line</param>
            <param name="lineDirection">Direction along which the line extends</param>
            <returns>The intersection points between the ray and the line, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray2Line2ColliderTest">
            <summary>Test for the Ray2 to Line2 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Line2ColliderTest.TestRayParallelToLine">
            <summary>Ensures no collisions are reported between two parallel rays</summary>
            <remarks>
              Even if two rays start at exactly the same place, no collision will be reported
              for parallel lines. Think of lines as infinitely thin - they do not take up any
              space and it's infinitely unlikely to touch another line if you're not crossing
              it. In addition to that, the contacts would be rays, not points and couldn't
              be returned in the LineContacts structure.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Line2ColliderTest.TestRayCrossingLine">
            <summary>Validates that the intersection of two crossing lines is detected</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Line2ColliderTest.TestRayBehindCrossingLine">
            <summary>Validates that a ray behind a crossing line results in no collision</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray2Triangle2Collider">
            <summary>Contains all Ray2 to Triangle2 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Triangle2Collider.FindContacts(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Determines where a ray will hit a triangle, if at all</summary>
            <param name="rayStart">Starting point of the ray</param>
            <param name="rayDirection">Direction into which the ray extends</param>
            <param name="triangleA">
              First corner point of triangle in counter-clockwise order
            </param>
            <param name="triangleB">
              Second corner point of triangle in counter-clockwise order
            </param>
            <param name="triangleC">
              Third corner point of triangle in counter-clockwise order
            </param>
            <returns>The intersection points between the ray and the box, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray2Triangle2ColliderTest">
            <summary>Test for the Ray2 to Triangle2 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Triangle2ColliderTest.TestRayStartingInside">
            <summary>
              Tests whether the contact finder reports the correct locations for a ray
              that starts inside a triangle.
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray2Triangle2ColliderTest.TestRayStartingBehind">
            <summary>
              Tests whether the contact finder reports the correct locations for a ray
              that starts behind a triangle.
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray3Aabb3Collider">
            <summary>Contains all Ray3 to Aabb3 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Aabb3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines where a ray will hit a box, if at all</summary>
            <param name="rayStart">Starting point of the ray</param>
            <param name="rayDirection">Direction into which the ray extends</param>
            <param name="boxExtents">Extents of the axis aligned box </param>
            <returns>The intersection points between the ray and the box, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray3Aabb3ColliderTest">
            <summary>Test for the Ray3 to Aabb3 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Aabb3ColliderTest.TestRayStartingInside">
            <summary>Validates the proper behavior if the ray starts inside the box</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Aabb3ColliderTest.TestRayStartingBehind">
            <summary>Validates the proper behavior if the ray starts behind the box</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray3Plane3Collider">
            <summary>Contains all Ray3 to Plane3 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Plane3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines where a ray will hit a plane, if at all</summary>
            <param name="rayStart">Starting point of the ray</param>
            <param name="rayDirection">Direction into which the ray extends</param>
            <param name="planeOffset">Offset of the plane</param>
            <param name="planeNormal">Normal vector of the plane</param>
            <returns>The intersection points between the ray and the plane, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray3Plane3ColliderTest">
            <summary>Test for the Ray3 to Plane3 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Plane3ColliderTest.TestPointingAway">
            <summary>Tests the collider with a ray pointing away from the plane</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Plane3ColliderTest.TestPointingTowards">
            <summary>Tests the collider with a ray pointing towards the plane</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray3Sphere3Collider">
            <summary>Contains all Ray3 to Sphere3 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Sphere3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Determines where a ray will hit a sphere, if at all</summary>
            <param name="rayStart">Starting point of the ray</param>
            <param name="rayDirection">Direction into which the ray extends</param>
            <param name="sphereRadius">Radius of the sphere</param>
            <returns>The intersection points between the ray and the box, if any</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Sphere3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Determines where a ray will hit a sphere, if at all</summary>
            <param name="rayStart">Starting point of the ray</param>
            <param name="rayDirection">Direction into which the ray extends</param>
            <param name="sphereCenter">Center of the sphere</param>
            <param name="sphereRadius">Radius of the sphere</param>
            <returns>The intersection points between the ray and the box, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray3Sphere3ColliderTest">
            <summary>Test for the Ray3 to Sphere3 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Sphere3ColliderTest.TestRayStartingInside">
            <summary>Validates the proper behavior if the ray starts inside the sphere</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Sphere3ColliderTest.TestRayStartingBehind">
            <summary>Validates the proper behavior if the ray starts behind the sphere</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Sphere3ColliderTest.TestRayStartingInsideWithAbsoluteDiscPosition">
            <summary>Validates the proper behavior if the ray starts inside the sphere</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Sphere3ColliderTest.TestRayStartingBehindWithAbsoluteDiscPosition">
            <summary>Validates the proper behavior if the ray starts behind the sphere</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray3Triangle3Collider">
            <summary>Contains all Ray3 to Triangle3 interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Triangle3Collider.FindContacts(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines the contact location between a ray and a triangle</summary>
            <param name="rayStart">
              Offset of the ray from the coordinate system's center
            </param>
            <param name="rayDirection">Direction of the line</param>
            <param name="triangleA">
              First corner point of triangle in counter-clockwise order
            </param>
            <param name="triangleB">
              Second corner point of triangle in counter-clockwise order
            </param>
            <param name="triangleC">
              Third corner point of triangle in counter-clockwise order
            </param>
            <returns>The point of intersection of the line with the triangle, if any</returns>
            <remarks>
              <para>
                I saw this algorithm in an article to line/triangle intersections tests
                by Christopher Bartlett. The material was stated to be free for learning
                purposes, so I felt free to apply what I've learned here =)
              </para>
              <para>
                There is no special case for when the line precisely touches one of
                the triangle's corners. It will either enter and exit the triangle or
                no contacts will be detected at all.
              </para>
            </remarks>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Ray3Triangle3ColliderTest">
            <summary>Test for the Ray3 to Triangle3 interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Triangle3ColliderTest.TestRayStartingBehind">
            <summary>
              Verifies that no contact is detected if the ray begins behind the triangle
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Collisions.Ray3Triangle3ColliderTest.TestHitThroughCenter">
            <summary>
              Tests whether the contact finder reports the correct locations for a line
              that crosses a triangle through its center 
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Segment3Aabb3Collider">
            <summary>Contains all Segment3 to Aabb3 interference detection code</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Collisions.Segment3Aabb3ColliderTest">
            <summary>Test for the Segment3 to Aabb3 interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.LineContacts">
            <summary>
              Stores the times of first and last contact determined in an intersection test
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContacts.#ctor(System.Single)">
            <summary>Initializes a new contact point</summary>
            <param name="touchTime">Time the contact was made at</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContacts.#ctor(System.Single,System.Single)">
            <summary>Initializes a new contact point</summary>
            <param name="entryTime">Time the first contact was made at</param>
            <param name="exitTime">Time the last contact has occured</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContacts.op_Implicit(Nuclex.Geometry.Lines.LineContacts)~System.Single[]">
            <summary>Converts a line contact record into a floating point array</summary>
            <param name="contacts">Contact record that will be converted</param>
            <returns>The resulting floating point array</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContacts.Equals(System.Object)">
            <summary>
              Determines whether this instance is identical to another instance
            </summary>
            <param name="otherObject">Other instance of compare against</param>
            <returns>True if both instances are identical</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContacts.GetHashCode">
            <summary>Returns a hash code for the instance</summary>
            <returns>The instance's hash code</returns>
        </member>
        <member name="F:Nuclex.Geometry.Lines.LineContacts.None">
            <summary>A line contacts instance for reporting no contacts</summary>
        </member>
        <member name="F:Nuclex.Geometry.Lines.LineContacts.EntryTime">
            <summary>Time the first contact was made</summary>
        </member>
        <member name="F:Nuclex.Geometry.Lines.LineContacts.ExitTime">
            <summary>Time the last contact occurred</summary>
        </member>
        <member name="P:Nuclex.Geometry.Lines.LineContacts.HasContact">
            <summary>Whether a contact is stored in the line contacts instance</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.ILine2">
            <summary>Straight line situated in 2D space</summary>
            <remarks>
              This is the generalized interface to all kinds of lines (including rays and
              line segments). Be careful not to mistake this for an infinite Line like it
              is represented by the Line2 class.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.ILine2.ClosestPointTo(Microsoft.Xna.Framework.Vector2)">
            <summary>Determines the closest point on the ray to the specified location</summary>
            <param name="location">Random location to which the closest point is determined</param>
            <returns>The closest point within the ray</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.ILine3">
            <summary>One-dimensional range situated in 3D space</summary>
            <remarks>
              This is the generalized interface to all kinds of lines (including rays and
              line segments). Be careful not to mistake this for an infinite Line like it
              is represented by the Line3 class.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.ILine3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Determines the closest point on the range to the specified location</summary>
            <param name="location">Random location to which the closest point is determined</param>
            <returns>The closest point within the range</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.ILine3.FindContacts(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines where the range clips a sphere</summary>
            <param name="sphere">Sphere that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the sphere</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.ILine3.FindContacts(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines where the range clips an axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the box</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.ILine3.FindContacts(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines where the range clips a box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the box</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.ILine3.FindContacts(Nuclex.Geometry.Areas.Plane3)">
            <summary>Determines where the range clips a plane</summary>
            <param name="plane">Plane that will be checked for intersection</param>
            <returns>The times at which the range touches the plane, if at all</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.ILine3.FindContacts(Nuclex.Geometry.Areas.Triangle3)">
            <summary>Determines where the range clips a triangle</summary>
            <param name="triangle">Triangle that will be checked for intersection</param>
            <returns>The times at which the range touches the triangle, if at all</returns>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Line2">
            <summary>Line (extending to infinity on both directions)</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2.#ctor">
            <summary>Constructs a new line</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2.#ctor(Nuclex.Geometry.Lines.Line2)">
            <summary>Constructs a new line as copy of an existing instance</summary>
            <param name="other">Existing instance to copy</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Initializes a new line</summary>
            <param name="offset">Offset of the line from the coordinate system's center</param>
            <param name="direction">Vector the defines the direction of the line</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2.ClosestPointTo(Microsoft.Xna.Framework.Vector2)">
            <summary>Locates the nearest point on the line to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point on the line to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2.op_Inequality(Nuclex.Geometry.Lines.Line2,Nuclex.Geometry.Lines.Line2)">
            <summary>Checks two line instances for inequality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if the instances differ or exactly one reference is set to null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2.op_Equality(Nuclex.Geometry.Lines.Line2,Nuclex.Geometry.Lines.Line2)">
            <summary>Checks two line instances for equality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if both instances are equal or both references are null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2.Equals(System.Object)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2.Equals(Nuclex.Geometry.Lines.Line2)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2.GetHashCode">
            <summary>Obtains a hash code of this instance</summary>
            <returns>The hash code of the instance</returns>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Line2.Offset">
            <summary>Offset of the line from the coordinate system's center</summary>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Line2.Direction">
            <summary>Direction into which the line extends</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Line2Test">
            <summary>Tests the implementation of the Line2 class</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2Test.TestEqualityOperator">
            <summary>Validates the equality operator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2Test.TestEqualityOperatorAgainstNull">
            <summary>Checks whether the equality operator properly handles null</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2Test.TestConstructor">
            <summary>Tests whether the constructors are working properly</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2Test.TestClosestPointHorizontal">
            <summary>Tests whether the closest point determination works on the X axis</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2Test.TestClosestPointVertical">
            <summary>Tests whether the closest point determination works on the Y axis</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line2Test.TestSerialization">
            <summary>Tests whether the class is serialized properly</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Line3">
            <summary>Line (extending to infinity on both directions)</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.#ctor">
            <summary>Initializes a new line</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.#ctor(Nuclex.Geometry.Lines.Line3)">
            <summary>Constructs a new line as copy of an existing instance</summary>
            <param name="other">Existing instance to copy</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Initializes a new line</summary>
            <param name="offset">Offset of the line from the coordinate system's center</param>
            <param name="direction">Vector the defines the direction of the line</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point on the line to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point on the line to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.op_Inequality(Nuclex.Geometry.Lines.Line3,Nuclex.Geometry.Lines.Line3)">
            <summary>Checks two line instances for inequality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if the instances differ or exactly one reference is set to null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.op_Equality(Nuclex.Geometry.Lines.Line3,Nuclex.Geometry.Lines.Line3)">
            <summary>Checks two line instances for equality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if both instances are equal or both references are null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.Equals(System.Object)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.Equals(Nuclex.Geometry.Lines.Line3)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.GetHashCode">
            <summary>Obtains a hash code of this instance</summary>
            <returns>The hash code of the instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.FindContacts(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines where the range clips a sphere</summary>
            <param name="sphere">Sphere that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.FindContacts(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines where the range clips an axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.FindContacts(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines where the range clips a box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.FindContacts(Nuclex.Geometry.Areas.Triangle3)">
            <summary>Determines where the range clips a triangle</summary>
            <param name="triangle">Triangle that will be checked for intersection</param>
            <returns>The times at which the range touches the triangle, if at all</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3.FindContacts(Nuclex.Geometry.Areas.Plane3)">
            <summary>Determines where the range clips a plane</summary>
            <param name="plane">Plane that will be checked for intersection</param>
            <returns>The times at which the range touches the plane, if at all</returns>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Line3.Offset">
            <summary>Offset of the line from the coordinate system's center</summary>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Line3.Direction">
            <summary>Direction into which the line extends</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Line3Test">
            <summary>Tests the implementation of the Line3 class</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestEqualityOperator">
            <summary>Validates the equality operator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestEqualityOperatorAgainstNull">
            <summary>Checks whether the equality operator properly handles null</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestConstructor">
            <summary>Tests whether the constructors are working properly</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestClosestPoint">
            <summary>Tests whether the closest point determination works</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestFindContactsOnAxisAlignedBox">
            <summary>Ensures that the contact finding method works for axis aligned boxes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestFindContactsOnOrientedBox">
            <summary>Ensures that the contact finding method works for oriented boxes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestFindContactsOnSphere">
            <summary>Ensures that the contact finding method works for spheres</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestFindContactsOnPlane">
            <summary>Ensures that the contact finding method works for planes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestFindOrthogonalContactsOnTriangle">
            <summary>
              Ensures that the contact finding method works for triangles that are directly
              pierced by an orthogonal line
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestFindSideContactsOnTriangle">
            <summary>
              Ensures that the contact finding method works for triangles that are touched
              on their sides by a line
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Line3Test.TestSerialization">
            <summary>Tests whether the class is serialized properly</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.LineContactsTest">
            <summary>Test for the LineContacts class</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContactsTest.TestSingleContactConstructor">
            <summary>
              Verifies that the constructor for a single contact point is working
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContactsTest.TestFullConstructor">
            <summary>
              Tests the constructor with normal entry and exit contact times
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContactsTest.TestNoneConstant">
            <summary>Verifies that the LineContacts.None constant has no contacts</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContactsTest.TestGetHashCode">
            <summary>
              Verifies that the GetHashCode() method returns the same hash code for
              two identical instances
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.LineContactsTest.TestEqualityComparison">
            <summary>
              Verifies that the Equals() method is working correctly
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Ray2">
            <summary>A Ray from some origin to infinity</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2.#ctor">
            <summary>Initializes a new ray</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2.#ctor(Nuclex.Geometry.Lines.Ray2)">
            <summary>Constructs a new line as copy of an existing instance</summary>
            <param name="other">Existing instance to copy</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Initializes a new ray</summary>
            <param name="origin">Location from which the ray originates</param>
            <param name="direction">Direction into which the ray goes</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2.ClosestPointTo(Microsoft.Xna.Framework.Vector2)">
            <summary>Determines the closest point on the ray to the specified location</summary>
            <param name="location">Random loation to which the closest point is determined</param>
            <returns>The closest point within the ray</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2.op_Inequality(Nuclex.Geometry.Lines.Ray2,Nuclex.Geometry.Lines.Ray2)">
            <summary>Checks two ray instances for inequality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if the instances differ or exactly one reference is set to null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2.op_Equality(Nuclex.Geometry.Lines.Ray2,Nuclex.Geometry.Lines.Ray2)">
            <summary>Checks two ray instances for equality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if both instances are equal or both references are null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2.Equals(System.Object)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2.Equals(Nuclex.Geometry.Lines.Ray2)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2.GetHashCode">
            <summary>Obtains a hash code of this instance</summary>
            <returns>The hash code of the instance</returns>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Ray2.Origin">
            <summary>Origin of the ray</summary>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Ray2.Direction">
            <summary>Normalized direction into which the ray goes</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Ray2Test">
            <summary>Tests the implementation of the Ray2 class</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2Test.TestEqualityOperator">
            <summary>Validates the equality operator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2Test.TestEqualityOperatorAgainstNull">
            <summary>Checks whether the equality operator properly handles null</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2Test.TestConstructor">
            <summary>Tests whether the constructors are working properly</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2Test.TestClosestPointHorizontal">
            <summary>Tests whether the closest point determination works on the X axis</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2Test.TestClosestPointVertical">
            <summary>Tests whether the closest point determination works on the Y axis</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray2Test.TestSerialization">
            <summary>Tests whether the class is serialized properly</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Ray3">
            <summary>A Ray from some origin to infinity</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.#ctor">
            <summary>Initializes a new ray</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.#ctor(Nuclex.Geometry.Lines.Ray3)">
            <summary>Constructs a new line as copy of an existing instance</summary>
            <param name="other">Existing instance to copy</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Initializes a new ray</summary>
            <param name="origin">Location from which the ray originates</param>
            <param name="direction">Direction into which the ray goes</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Determines the closest point on the ray to the specified location</summary>
            <param name="location">Random location to which the closest point is determined</param>
            <returns>The closest point within the ray</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.op_Inequality(Nuclex.Geometry.Lines.Ray3,Nuclex.Geometry.Lines.Ray3)">
            <summary>Checks two ray instances for inequality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if the instances differ or exactly one reference is set to null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.op_Equality(Nuclex.Geometry.Lines.Ray3,Nuclex.Geometry.Lines.Ray3)">
            <summary>Checks two ray instances for equality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if both instances are equal or both references are null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.Equals(System.Object)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.Equals(Nuclex.Geometry.Lines.Ray3)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.GetHashCode">
            <summary>Obtains a hash code of this instance</summary>
            <returns>The hash code of the instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.FindContacts(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines where the range clips a sphere</summary>
            <param name="sphere">Sphere that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.FindContacts(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines where the range clips an axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.FindContacts(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines where the range clips a box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.FindContacts(Nuclex.Geometry.Areas.Plane3)">
            <summary>Determines where the range clips a plane</summary>
            <param name="plane">Plane that will be checked for intersection</param>
            <returns>The times at which the range touches the plane, if at all</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.FindContacts(Nuclex.Geometry.Areas.Triangle3)">
            <summary>Determines where the range clips a triangle</summary>
            <param name="triangle">Triangle that will be checked for intersection</param>
            <returns>The times at which the range touches the triangle, if at all</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.limitContactToRay(Nuclex.Geometry.Lines.LineContacts@)">
            <summary>
              Limits the contact positions found in a line to the subsection of
              the line covered by the line segment
            </summary>
            <param name="contacts">Contacts that will be limited to the line segment</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3.filterContacts(System.Single[])">
            <summary>Filters the contacts of a line contact query for the ray</summary>
            <param name="lineContacts">Contacts that will be filtered</param>
            <returns>The filtered contact list</returns>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Ray3.Origin">
            <summary>Origin of the ray</summary>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Ray3.Direction">
            <summary>Normalized direction into which the ray goes</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Ray3Test">
            <summary>Tests the implementation of the Ray3 class</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestEqualityOperator">
            <summary>Validates the equality operator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestEqualityOperatorAgainstNull">
            <summary>Checks whether the equality operator properly handles null</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestConstructor">
            <summary>Tests whether the constructors are working properly</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestClosestPoint">
            <summary>Tests whether the closest point determination works</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestFindContactsOnAxisAlignedBox">
            <summary>Ensures that the contact finding method works for axis aligned boxes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestFindContactsOnOrientedBox">
            <summary>Ensures that the contact finding method works for oriented boxes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestFindContactsOnSphere">
            <summary>Ensures that the contact finding method works for spheres</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestFindContactsOnPlane">
            <summary>Ensures that the contact finding method works for planes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestFindOrthogonalContactOnTriangle">
            <summary>
              Ensures that the contact finding method can find a direct orthogonal ray
              passing through the triangle
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestFindSideContactOnTriangle">
            <summary>
              Ensures that the contact finding method can detect contacts with rays
              touching the outside of the triangle
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Ray3Test.TestSerialization">
            <summary>Tests whether the class is serialized properly</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Segment2">
            <summary>Segment of a line (Typical line with starting and ending location)</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.#ctor">
            <summary>Initializes a new line segment</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.#ctor(Nuclex.Geometry.Lines.Segment2)">
            <summary>Constructs a new line as copy of an existing instance</summary>
            <param name="other">Existing instance to copy</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Initializes a new line segment</summary>
            <param name="start">Starting location of the line segment</param>
            <param name="end">Ending location of the line segment</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.ClosestPointTo(Microsoft.Xna.Framework.Vector2)">
            <summary>Locates the nearest point on the line to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point on the line to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.op_Inequality(Nuclex.Geometry.Lines.Segment2,Nuclex.Geometry.Lines.Segment2)">
            <summary>Checks two segment instances for inequality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if the instances differ or exactly one reference is set to null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.op_Equality(Nuclex.Geometry.Lines.Segment2,Nuclex.Geometry.Lines.Segment2)">
            <summary>Checks two segment instances for equality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if both instances are equal or both references are null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.Equals(System.Object)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.Equals(Nuclex.Geometry.Lines.Segment2)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.GetHashCode">
            <summary>Obtains a hash code of this instance</summary>
            <returns>The hash code of the instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2.Orientation(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Locate which side of a line a point is on</summary>
            <param name="start">Starting point of a line segment that is interpreted as line</param>
            <param name="end">Ending point of a line segment that is interpreted as line</param>
            <param name="point">Location which is checked for the side it is on</param>
            <returns>1 if it is on the positive side, -1 for negative, 0 for on the line</returns>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Segment2.Start">
            <summary>The starting point of the line segment</summary>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Segment2.End">
            <summary>The ending point of the line segment</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Segment2Test">
            <summary>Tests the implementation of the LineSegment2 class</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2Test.TestEqualityOperator">
            <summary>Validates the equality operator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2Test.TestEqualityOperatorAgainstNull">
            <summary>Checks whether the equality operator properly handles null</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2Test.TestConstructor">
            <summary>Tests whether the constructors are working properly</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2Test.TestClosestPointHorizontal">
            <summary>Tests whether the closest point determination works on the X axis</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2Test.TestClosestPointVertical">
            <summary>Tests whether the closest point determination works on the Y axis</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment2Test.TestSerialization">
            <summary>Tests whether the class is serialized properly</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Segment3">
            <summary>Segment of a line (Typical line with starting and ending location)</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.#ctor">
            <summary>Initializes a new line segment</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.#ctor(Nuclex.Geometry.Lines.Segment3)">
            <summary>Constructs a new line as copy of an existing instance</summary>
            <param name="other">Existing instance to copy</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Initializes a new line segment</summary>
            <param name="start">Starting location of the line segment</param>
            <param name="end">Ending location of the line segment</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point on the line to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point on the line to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.op_Inequality(Nuclex.Geometry.Lines.Segment3,Nuclex.Geometry.Lines.Segment3)">
            <summary>Checks two segment instances for inequality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if the instances differ or exactly one reference is set to null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.op_Equality(Nuclex.Geometry.Lines.Segment3,Nuclex.Geometry.Lines.Segment3)">
            <summary>Checks two segment instances for equality</summary>
            <param name="first">First instance to be compared</param>
            <param name="second">Second instance fo tbe compared</param>
            <returns>True if both instances are equal or both references are null</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.Equals(System.Object)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.Equals(Nuclex.Geometry.Lines.Segment3)">
            <summary>Checks whether another instance is equal to this instance</summary>
            <param name="other">Other instance to compare to this instance</param>
            <returns>True if the other instance is equal to this instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.GetHashCode">
            <summary>Obtains a hash code of this instance</summary>
            <returns>The hash code of the instance</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.FindContacts(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines where the range clips a sphere</summary>
            <param name="sphere">Sphere that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.FindContacts(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines where the range clips an axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.FindContacts(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines where the range clips a box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.FindContacts(Nuclex.Geometry.Areas.Plane3)">
            <summary>Determines where the range clips a plane</summary>
            <param name="plane">Plane that will be checked for intersection</param>
            <returns>The times at which the range touches the plane, if at all</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.FindContacts(Nuclex.Geometry.Areas.Triangle3)">
            <summary>Determines where the range clips a triangle</summary>
            <param name="triangle">Triangle that will be checked for intersection</param>
            <returns>The times at which the range touches the triangle, if at all</returns>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.Intersects(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines where the range clips an axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>The times at which the range enters or leaves the volume</returns>
            <remarks>
              Taken from the article "Simple Intersection Tests for Games" on
              Gamasutra by Gomez et al.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.limitContactToLineSegment(Nuclex.Geometry.Lines.LineContacts@)">
            <summary>
              Limits the contact positions found in a line to the subsection of
              the line covered by the line segment
            </summary>
            <param name="contacts">Contacts that will be limited to the line segment</param>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3.filterContacts(System.Single[])">
            <summary>Filters the contacts of a line contact query for the segment</summary>
            <param name="lineContacts">Contacts that will be filtered</param>
            <returns>The filtered contact list</returns>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Segment3.Start">
            <summary>The starting point of the line segment</summary>
        </member>
        <member name="F:Nuclex.Geometry.Lines.Segment3.End">
            <summary>The ending point of the line segment</summary>
        </member>
        <member name="P:Nuclex.Geometry.Lines.Segment3.Length">
            <summary>The length of the line</summary>
        </member>
        <member name="T:Nuclex.Geometry.Lines.Segment3Test">
            <summary>Tests the implementation of the Ray2 class</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestEqualityOperator">
            <summary>Validates the equality operator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestEqualityOperatorAgainstNull">
            <summary>Checks whether the equality operator properly handles null</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestConstructor">
            <summary>Tests whether the constructors are working properly</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestClosestPoint">
            <summary>Tests whether the closest point determination works</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestFindContactsOnAxisAlignedBox">
            <summary>Ensures that the contact finding method works for axis aligned boxes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestFindContactsOnOrientedBox">
            <summary>Ensures that the contact finding method works for oriented boxes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestFindContactsOnSphere">
            <summary>Ensures that the contact finding method works for spheres</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestFindContactsOnPlane">
            <summary>Ensures that the contact finding method works for planes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestFindOrthogonalContactsOnTriangle">
            <summary>
              Ensures that the contact finding method detects a line segment that
              directly pierces the triangle orthogonally
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestFindSideContactsOnTriangle">
            <summary>
              Ensures that the contact finding method detects a line segment that
              touches the sides of the triangle
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.Lines.Segment3Test.TestSerialization">
            <summary>Tests whether the class is serialized properly</summary>
        </member>
        <member name="T:Nuclex.Geometry.MatrixHelper">
            <summary>Provides helper methods for working with matrices</summary>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelper.Create(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Creates a new matrix from the given directional vectors</summary>
            <param name="right">Vector that's pointing to the right in the matrix</param>
            <param name="up">Vector that's pointing upwards in the matrix</param>
            <param name="backward">Vector that's pointing backwards in the matrix</param>
            <returns>The new matrix</returns>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelper.Create(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
              Creates a new matrix from the given directional vectors and a translational
            </summary>
            <param name="translation">Positional translation done by the matrix</param>
            <param name="right">Vector that's pointing to the right in the matrix</param>
            <param name="up">Vector that's pointing upwards in the matrix</param>
            <param name="backward">Vector that's pointing backwards in the matrix</param>
            <returns>The new matrix</returns>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelper.Get(Microsoft.Xna.Framework.Matrix@,System.Int32)">
            <summary>Retrieves a row of the matrix as a vector</summary>
            <param name="matrix">Matrix of which to retrieve a row</param>
            <param name="row">Index of the row that will be retrieved</param>
            <returns>The vector built from the requested matrix row</returns>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelper.Get(Microsoft.Xna.Framework.Matrix@,System.Int32,System.Int32)">
            <summary>Retrieves an element of the matrix by its column and row index</summary>
            <param name="matrix">Matrix of which to retrieve an element</param>
            <param name="row">Index of the row from which to retrieve the element</param>
            <param name="col">Index of the column to retrieve</param>
            <returns>The element at the given row and column</returns>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelper.Set(Microsoft.Xna.Framework.Matrix@,System.Int32,Microsoft.Xna.Framework.Vector3)">
            <summary>Sets a row of the matrix from a vector</summary>
            <param name="matrix">Matrix in which to set a row</param>
            <param name="row">Index of the row that will be set</param>
            <param name="values">Vector containing the values to assign to the row</param>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelper.Set(Microsoft.Xna.Framework.Matrix@,System.Int32,System.Int32,System.Single)">
            <summary>Set an element of the matrix by its column and row index</summary>
            <param name="matrix">Matrix in which to set an element</param>
            <param name="row">Index of the row in which to set an element</param>
            <param name="col">Index of the column to set</param>
            <param name="value">
              Value to set to the matrix element at the specified row and column
            </param>
        </member>
        <member name="T:Nuclex.Geometry.GeoAssertHelper">
            <summary>Contains assertions on geometrical objects</summary>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelper.AreAlmostEqual(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Int32)">
            <summary>Ensures that two vectors are equal</summary>
            <param name="expected">Expected vector</param>
            <param name="actual">Actual vector</param>
            <param name="deltaUlps">Allowed deviation in representable floating point values</param>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelper.AreAlmostEqual(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Int32,System.String)">
            <summary>Ensures that two vectors are equal</summary>
            <param name="expected">Expected vector</param>
            <param name="actual">Actual vector</param>
            <param name="deltaUlps">Allowed deviation in representable floating point values</param>
            <param name="message">Message to display when the vectors are not equal</param>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelper.AreAlmostEqual(Nuclex.Geometry.Volumes.AxisAlignedBox3,Nuclex.Geometry.Volumes.AxisAlignedBox3,System.Int32)">
            <summary>Ensures that two axis aligned boxes are equal</summary>
            <param name="expected">Expected box</param>
            <param name="actual">Actual box</param>
            <param name="deltaUlps">Allowed deviation in representable floating point values</param>
        </member>
        <member name="M:Nuclex.Geometry.GeoAssertHelper.AreAlmostEqual(Nuclex.Geometry.Volumes.AxisAlignedBox3,Nuclex.Geometry.Volumes.AxisAlignedBox3,System.Int32,System.String)">
            <summary>Ensures that two axis aligned boxes are equal</summary>
            <param name="expected">Expected box</param>
            <param name="actual">Actual box</param>
            <param name="deltaUlps">Allowed deviation in representable floating point values</param>
            <param name="message">Message to display when the boxes are not equal</param>
        </member>
        <member name="T:Nuclex.Geometry.MatrixHelperTest">
            <summary>Unit Test for the matrix helper class</summary>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelperTest.TestCreateMatrixFromVectors">
            <summary>
              Verifies that the matrix helper can construct a matrix from individual vectors
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelperTest.TestCreateMatrixFromVectorsAndTranslation">
            <summary>
              Verifies that the matrix helper can construct a matrix from individual vectors
              together with a translation point
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelperTest.TestGetAndSetMatrixElementsByIndex">
            <summary>
              Verifies that the matrix helper can be used to obtain and assign individual
              elements of a matrix by their indices
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelperTest.TestThrowOnGetMatrixElementWithInvalidIndex">
            <summary>
              Verifies that the matrix helper throws an exception when an invalid index to
              read from is specified
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelperTest.TestThrowOnSetMatrixElementWithInvalidIndex">
            <summary>
              Verifies that the matrix helper throws an exception when an invalid index to
              write to is specified
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelperTest.TestGetAndSetMatrixRowsByIndex">
            <summary>
              Verifies that the matrix helper can be used to obtain and assign individual
              rows of a matrix by their indices
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelperTest.TestThrowOnGetMatrixRowWithInvalidIndex">
            <summary>
              Verifies that the matrix helper throws an exception when an invalid row index
              to read from is specified
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.MatrixHelperTest.TestThrowOnSetMatrixRowWithInvalidIndex">
            <summary>
              Verifies that the matrix helper throws an exception when an invalid row index
              to write to is specified
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.VectorHelper">
            <summary>Provides helper methods for vectors</summary>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelper.Abs(Microsoft.Xna.Framework.Vector3)">
            <summary>Calculates the absolute values of each vector component</summary>
            <param name="vector">Vector of which to calculate the absolute</param>
            <returns>A new vector with the absolute value of the input vector</returns>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelper.Get(Microsoft.Xna.Framework.Vector3@,System.Int32)">
            <summary>Retrieves a vector component by its index</summary>
            <param name="vector">Vector to retrieve a component of</param>
            <param name="component">Index of the component to retrieve</param>
            <returns>The value of the vector's indicated component</returns>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelper.Set(Microsoft.Xna.Framework.Vector3@,System.Int32,System.Single)">
            <summary>Sets a vector component by its index</summary>
            <param name="vector">Vector to set a component of</param>
            <param name="component">Index of the component to set</param>
            <param name="value">Value to assign to the vector's indicated component</param>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelper.GetPerpendicularVector(Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a vector that is perpendicular to the input vector</summary>
            <param name="vector">Vector to which a perpendicular vector will be found</param>
            <returns>A vector that is perpendicular to the input vector</returns>
            <remarks>
              <para>
                This method does not care for the orientation of the resulting vector, so it
                shouldn't be used for billboards or to orient a view matrix. On the other hand,
                if you don't care for the orientation of the resulting vector, only that it is
                perpendicular, this method can provide better numerical stability and
                performance than a generic LookAt() method.
              </para>
              <para>
                References:
                http://www.gamedev.net/community/forums/topic.asp?topic_id=445164
                http://www.gamedev.net/community/forums/topic.asp?topic_id=518142
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelper.GetPerpendicularVector(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
            <summary>Returns a vector that is perpendicular to the input vector</summary>
            <param name="vector">Vector to which a perpendicular vector will be found</param>
            <param name="perpendicular">
              Output parameter that receives a vector perpendicular to the provided vector
            </param>
            <remarks>
              <para>
                This method does not care for the orientation of the resulting vector, so it
                shouldn't be used for billboards or to orient a view matrix. On the other hand,
                if you don't care for the orientation of the resulting vector, only that it is
                perpendicular, this method can provide better numerical stability and
                performance than a generic LookAt() method.
              </para>
              <para>
                References:
                http://www.gamedev.net/community/forums/topic.asp?topic_id=445164
                http://www.gamedev.net/community/forums/topic.asp?topic_id=518142
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelper.AbsMax(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
              Builds a vector consisting of the larger absolute values from both inputs
            </summary>
            <param name="first">First vector to look for the larger absolute values in</param>
            <param name="second">Second vector to look for the larger absolute values in</param>
            <returns>
              A vector consisting of the larger absolute values from both input vectors
            </returns>
            <remarks>
              This works similar to the Vector2.Max() method, but it will not use
              the element from the input vector that has the greater value, but look
              for the element with the greater absolute value. Thus, for the inputs
              {-10, -1} and {1, 10} it would return {-10, 10}.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelper.AbsMax(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
              Builds a vector consisting of the larger absolute values from both inputs
            </summary>
            <param name="first">First vector to look for the larger absolute values in</param>
            <param name="second">Second vector to look for the larger absolute values in</param>
            <returns>
              A vector consisting of the larger absolute values from both input vectors
            </returns>
            <remarks>
              This works similar to the Vector2.Max() method, but it will not use
              the element from the input vector that has the greater value, but look
              for the element with the greater absolute value. Thus, for the inputs
              {-10, -1, 10} and {1, 10, -10} it would return {-10, 10, 10}.
            </remarks>
        </member>
        <member name="T:Nuclex.Geometry.VectorHelperTest">
            <summary>Unit Test for the vector helper class</summary>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelperTest.TestVectorAbs">
            <summary>
              Verifies that the vector helper can calculate the absolute value of the
              individual elements in a vector
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelperTest.TestGetAndSetVectorElementsByIndex">
            <summary>
              Verifies that the vector helper can be used to obtain and assign individual
              rows of a matrix by their indices
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelperTest.TestThrowOnGetVectorRowWithInvalidIndex">
            <summary>
              Verifies that the vector helper throws an exception when an invalid row index
              to read from is specified
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelperTest.TestThrowOnSetVectorRowWithInvalidIndex">
            <summary>
              Verifies that the vector helper throws an exception when an invalid row index
              to write to is specified
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelperTest.TestGetPerpendicularVector">
            <summary>
              Verifies that the vector helper can determine an arbitrary perpendicular vector
              to another vector
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelperTest.TestAbsMaxWithVector2">
            <summary>
              Tests whether the AbsMax() method is working correctly for 2D vectors
            </summary>
        </member>
        <member name="M:Nuclex.Geometry.VectorHelperTest.TestAbsMaxWithVector3">
            <summary>
              Tests whether the AbsMax() method is working correctly for 3D vectors
            </summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.AxisAlignedBox3">
            <summary>Three-dimensional axis aligned box</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.IVolume3">
            <summary>Three-dimensional geometric body</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.IVolume3.Accept(Nuclex.Geometry.Volumes.VolumeVisitor)">
            <summary>Accepts a visitor to access the concrete volume implementation</summary>
            <param name="visitor">Visitor to be accepted</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.IVolume3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the volume to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the volume to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.IVolume3.Intersects(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines if the volume clips the circle</summary>
            <param name="sphere">Circle that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.IVolume3.Intersects(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines if the volume clips the axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.IVolume3.Intersects(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines if the volume clips the box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.IVolume3.RandomPointOnSurface(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the volume's surface</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the volume's surface</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.IVolume3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point within the volume</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point within the volume</returns>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.IVolume3.BoundingBox">
            <summary>Smallest axis-aligned box that completely encloses the volume</summary>
            <remarks>
              This always produces an optimal box which means a tight-fitting box is generated
              that will touch the volume on each of its six sides. As a side effect, it is very
              likely that this box needs to be recalculated whenever the volume changes its
              orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.IVolume3.BoundingSphere">
            <summary>Smallest sphere that completely encloses the volume</summary>
            <remarks>
              Bounding spheres have the advantage to not change even when the volume is
              rotated. That makes them ideal for dynamic objects that are not keeping their
              original orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.IVolume3.Mass">
            <summary>Amount of mass that the volume contains</summary>
            <remarks>
              This is the mass the volume would have at a material density of 1.0
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.IVolume3.SurfaceArea">
            <summary>The volume's total surface area</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.IVolume3.CenterOfMass">
            <summary>Center of the volume's mass</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.IVolume3.InertiaTensor">
            <summary>The inetria tensor matrix of the volume</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Initializes a new box volume</summary>
            <param name="min">Lower left back bounds of the box</param>
            <param name="max">Upper right front bounds of the box</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.#ctor(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Initializes a new box volume as copy of an existing box</summary>
            <param name="other">Existing box that will be copied</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.Accept(Nuclex.Geometry.Volumes.VolumeVisitor)">
            <summary>Accepts a visitor to access the concrete volume implementation</summary>
            <param name="visitor">Visitor to be accepted</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the volume to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the volume to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.Intersects(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines if the volume clips the circle</summary>
            <param name="sphere">Circle that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.Intersects(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines if the volume clips the axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.Intersects(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines if the volume clips the box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.RandomPointOnSurface(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the volume's surface</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the volume's surface</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point within the volume</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point within the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.op_Equality(Nuclex.Geometry.Volumes.AxisAlignedBox3,Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines if two axis aligned boxes are equal</summary>
            <param name="first">First axis aligned box to be compared</param>
            <param name="second">Second axis aligned box to be compared</param>
            <returns>True if both axis aligned boxes are equal</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.op_Inequality(Nuclex.Geometry.Volumes.AxisAlignedBox3,Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines if two axis aligned boxes are unequal</summary>
            <param name="first">First axis aligned box to be compared</param>
            <param name="second">Second axis aligned box to be compared</param>
            <returns>True if both axis aligned boxes are unequal</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.Equals(System.Object)">
            <summary>Determines if an object is identical to the axis aligned box</summary>
            <param name="obj">Object to compare to</param>
            <returns>True if the object is identical to the axis aligned box</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.GetHashCode">
            <summary>Builds a hashing code for the instance</summary>
            <returns>The instance's hashing code</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3.ToString">
            <summary>Converts the axis aligned box to a readable string representation</summary>
            <returns>The axis aligned box as a string</returns>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.AxisAlignedBox3.Min">
            <summary>Lower left back bounds of the box</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.AxisAlignedBox3.Max">
            <summary>Upper right front bounds of the box</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.BoundingBox">
            <summary>Smallest box that encloses the volume in its entirety</summary>
            <remarks>
              This always produces an optimal box which means a tight-fitting box is generated
              that will touch the volume on each of its six sides. As a side effect, it is very
              likely that this box needs to be recalculated whenever the volume changes its
              orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.BoundingSphere">
            <summary>Smallest sphere that encloses the volume in its entirety</summary>
            <remarks>
              Bounding spheres have the advantage to not change even when the volume is
              rotated. That makes them ideal for dynamic objects that are not keeping their
              original orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.Mass">
            <summary>Amount of mass that the volume contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.SurfaceArea">
            <summary>The volume's total surface area</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.CenterOfMass">
            <summary>Center of the volume's mass</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.InertiaTensor">
            <summary>The inertia tensor matrix of the volume</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.Width">
            <summary>The width of the box (x axis)</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.Height">
            <summary>The height of the box (y axis)</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.Depth">
            <summary>The depth of the box (z axis)</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.Extents">
            <summary>Vector containing the extents of the box</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.Dimensions">
            <summary>Vector containing the dimensions of the box</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.AxisAlignedBox3.Center">
            <summary>The center of the box</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.AxisAlignedBox3Test">
            <summary>Test for the three-dimensional axis aligned box implementation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3Test.TestMassProperties">
            <summary>Tests whether the mass properties of the volume are working</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3Test.TestMovingBoxImpactPoint">
            <summary>Tests the intersection query on moving boxes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3Test.TestBoundingBox">
            <summary>Tests the bounding box generator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.AxisAlignedBox3Test.TestBoundingSphere">
            <summary>Tests the bounding sphere generator</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Box3">
            <summary>Three-dimensional box with arbitrary orientation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.#ctor(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Initializes a new instance of the oriented box</summary>
            <param name="transform">
              Transformation matrix that defines the box' rotation and translation
            </param>
            <param name="extents">The extents (half the dimensions) of the box</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.#ctor(Nuclex.Geometry.Volumes.Box3)">
            <summary>Initializes a new oriented box as copy of an existing box</summary>
            <param name="other">Existing box that will be copied</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.Accept(Nuclex.Geometry.Volumes.VolumeVisitor)">
            <summary>Accepts a visitor to access the concrete volume implementation</summary>
            <param name="visitor">Visitor to be accepted</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the volume to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the volume to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.Intersects(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines if the volume clips the circle</summary>
            <param name="sphere">Circle that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.Intersects(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines if the volume clips the axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.Intersects(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines if the volume clips the box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.RandomPointOnSurface(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the volume's surface</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the volume's surface</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point within the volume</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point within the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.op_Equality(Nuclex.Geometry.Volumes.Box3,Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines if two oriented boxes are equal</summary>
            <param name="first">First oriented box to be compared</param>
            <param name="second">Second oriented box to be compared</param>
            <returns>True if both axis oriented are equal</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.op_Inequality(Nuclex.Geometry.Volumes.Box3,Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines if two oriented boxes are unequal</summary>
            <param name="first">First oriented box to be compared</param>
            <param name="second">Second oriented box to be compared</param>
            <returns>True if both oriented boxes are unequal</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.Equals(System.Object)">
            <summary>Determines if an object is identical to the oriented box</summary>
            <param name="obj">Object to compare to</param>
            <returns>True if the object is identical to the oriented box</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.GetHashCode">
            <summary>Builds a hashing code for the instance</summary>
            <returns>The instance's hashing code</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3.ToString">
            <summary>Converts the oriented box to a readable string representation</summary>
            <returns>The axis oriented as a string</returns>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.Box3.Transform">
            <summary>Orientation of the box in 3D space</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.Box3.Extents">
            <summary>Box dimensions in the box' local coordinate system</summary>
            <remarks>
              These are the extents, not the dimensions. The dimensions are the
              total length of the box on each of its three local coordinate axes while
              the extents refer to the distance of each side from the center of the
              box, much like the radius and the diameter of a sphere.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Box3.BoundingBox">
            <summary>Smallest box that encloses the volume in its entirety</summary>
            <remarks>
              <para>
                This always produces an optimal box which means a tight-fitting box is generated
                that will touch the volume on each of its six sides. As a side effect, it is very
                likely that this box needs to be recalculated whenever the volume changes its
                orientation.
              </para>
              <para>
                This method was actually thought up by myself when all googling did not
                reveal a clever way to avoid the expensive matrix-vector multiplications.
                Feel free to use it in any way you see fit.
              </para>
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Box3.BoundingSphere">
            <summary>Smallest sphere that encloses the volume in its entirety</summary>
            <remarks>
              Bounding spheres have the advantage to not change even when the volume is
              rotated. That makes them ideal for dynamic objects that are not keeping their
              original orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Box3.Mass">
            <summary>Amount of mass that the volume contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Box3.SurfaceArea">
            <summary>The volume's total surface area</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Box3.CenterOfMass">
            <summary>Center of the volume's mass</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Box3.InertiaTensor">
            <summary>The inetria tensor matrix of the volume</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Box3.Dimensions">
            <summary>The dimensions of this box</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Box3.Center">
            <summary>Location of the box' center</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Box3Test">
            <summary>Test for the three-dimensional box implementation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3Test.TestMassProperties">
            <summary>Tests whether the mass properties of the volume are working</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Box3Test.TestBoundingBox">
            <summary>Tests the bounding box generator</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbAabbCollider">
            <summary>Contains all Aabb-to-Aabb interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbAabbCollider.CheckContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Test whether two axis aligned boxes are overlapping</summary>
            <param name="firstMin">Minimum coordinate of first box</param>
            <param name="firstMax">Maximum coordinate of first box</param>
            <param name="secondMin">Minimum coordinate of second box</param>
            <param name="secondMax">Maximum coordinate of second box</param>
            <returns>True if the boxes are intersecting each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbAabbCollider.FindContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Find the contact location between two axis aligned boxes</summary>
            <param name="firstMin">Minimum coordinate of first box</param>
            <param name="firstMax">Maximum coordinate of first box</param>
            <param name="secondMin">Minimum coordinate of second box</param>
            <param name="secondMax">Maximum coordinate of second box</param>
            <returns>A contact location if the boxes touch each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbAabbCollider.FindContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines the time when the box will hit another box</summary>
            <param name="firstMin">Minimum coordinate of first box</param>
            <param name="firstMax">Maximum coordinate of first box</param>
            <param name="secondMin">Minimum coordinate of second box</param>
            <param name="secondMax">Maximum coordinate of second box</param>
            <param name="secondVelocity">
              Velocity with which the second box is moving relative to the first box
            </param>
            <returns>The point of first contact, if any</returns>
            <remarks>
              <para>
                Conventional tests that resort to stepping often fail to detect collisions
                between fast-moving objects. This impact determination test will always
                detect a collision if it occurs, giving the exact time of the impact.
              </para>
              <para>
                This is a simplified test that assumes a linear trajectory and does
                not take object rotation into account. It is well suited to use on
                two bounding boxes in order to determine if a collision between the
                shapes contained is possible at all.
              </para>
              <para>
                Idea taken from the "Simple Intersection Tests for Games" article
                on gamasutra by Gomez.
                (http://www.gamasutra.com/features/19991018/Gomez_1.htm)
              </para>
            </remarks>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbAabbColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbAabbColliderTest.TestCheckContact">
            <summary>Tests intersection checking with two static AABBs</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbAabbColliderTest.TestFindDynamicContact">
            <summary>Tests intersection checking with moving AABBs</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbCylinderCollider">
            <summary>Contains all Aabb-to-Cylinder interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbCylinderCollider.CheckContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,System.Single,System.Single)">
            <summary>Test whether an axis aligned box and a cylinder are overlapping</summary>
            <param name="aabbMin">Minimum coordinate of the axis aligned box</param>
            <param name="aabbMax">Maximum coordinate of the axis aligned box</param>
            <param name="cylinderTransform">Center and orientation of the cylinder</param>
            <param name="cylinderLength">Length of the cylinder</param>
            <param name="cylinderRadius">Radius of the cylinder</param>
            <returns>True if the cylinder and the box are intersecting each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbCylinderCollider.FindContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,System.Single,System.Single)">
            <summary>Find the contact location between a cylinder and axis aligned box</summary>
            <param name="aabbMin">Minimum coordinate of the axis aligned box</param>
            <param name="aabbMax">Maximum coordinate of the axis aligned box</param>
            <param name="cylinderTransform">Center and orientation of the cylinder</param>
            <param name="cylinderLength">Length of the cylinder</param>
            <param name="cylinderRadius">Radius of the cylinder</param>
            <returns>A contact location if the cylinder touches the axis aligned box</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbCylinderColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbMeshCollider">
            <summary>Contains all Aabb-to-Mesh interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbMeshCollider.CheckContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Nuclex.Geometry.Volumes.TriangleMesh3)">
            <summary>Test whether an axis aligned box and a mesh are overlapping</summary>
            <param name="aabbMin">Minimum coordinate of the axis aligned box</param>
            <param name="aabbMax">Maximum coordinate of the axis aligned box</param>
            <param name="triangleMesh">Mesh to be checked for overlap</param>
            <returns>True if the axis aligned box and the mesh are intersecting</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbMeshCollider.FindContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Nuclex.Geometry.Volumes.TriangleMesh3)">
            <summary>Find the contact location between an axis aligned box and a mesh</summary>
            <param name="aabbMin">Minimum coordinate of the axis aligned box</param>
            <param name="aabbMax">Maximum coordinate of the axis aligned box</param>
            <param name="triangleMesh">Mesh to be checked for overlap</param>
            <returns>A contact location if the axis aligned box touches the mesh</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbCMeshColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbObbCollider">
            <summary>Contains all Aabb-to-Obb interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbObbCollider.CheckContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Checks an AABB for intersection with an OBB</summary>
            <param name="aabbExtents">Extents of the AABB</param>
            <param name="obbTransform">Orientation and position of the OBB</param>
            <param name="obbExtents">Extents of the OBB</param>
            <returns>True if the two boxes are overlapping</returns>
            <remarks>
              <para>
                This method is a helper method for the other intersection checks. It assumes the
                AABB is sitting right in the center of the coordinate frame. In other words,
                that the OBB has been transformed into the AABB's local coordinate frame.
              </para>
              <para>
                Idea taken from the "Simple Intersection Tests for Games" article
                on gamasutra by Gomez. The algorithm uses the separating axis test for
                all 15 potential separating axes. If a separating axis can not be found,
                the two boxes are overlapping.
                (http://www.gamasutra.com/features/19991018/Gomez_1.htm)
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbObbCollider.FindContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Find the contact location between an AABB and an OBB</summary>
            <param name="aabbMin">Minimum coordinates of the AABB</param>
            <param name="aabbMax">Maximum coordinates of the AABB</param>
            <param name="obbTransform">Orientation and position of the OBB</param>
            <param name="obbExtents">Extents of the OBB</param>
            <returns>A contact location if the axis aligned box touches the mesh</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbObbColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbObbColliderTest.TestAxisAlignedBoxBoxIntersection">
            <summary>Tests intersection checking between AABBs and OBBs</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbSphereCollider">
            <summary>Contains all Aabb-to-Sphere interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbSphereCollider.CheckContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Test whether a sphere and an axis aligned box intersect each other</summary>
            <param name="aabbMin">Minimum coordinate of the axis aligned box to test</param>
            <param name="aabbMax">Maximum coordinate of the axis aligned box to test</param>
            <param name="sphereCenter">Center to the sphere to test</param>
            <param name="sphereRadius">Radius to the sphere to test</param>
            <returns>True if the axis aligned box intersects with the sphere</returns>
            <remarks>
              Idea taken from the "Simple Intersection Tests for Games" article
              on gamasutra by Gomez.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.AabbSphereCollider.FindContact(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Find the contact location between an axis aligned box and a mesh</summary>
            <param name="aabbMin">Minimum coordinate of the axis aligned box to test</param>
            <param name="aabbMax">Maximum coordinate of the axis aligned box to test</param>
            <param name="sphereCenter">Center to the sphere to test</param>
            <param name="sphereRadius">Radius to the sphere to test</param>
            <returns>A contact location if the axis aligned box touches the mesh</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.AabbSphereColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.CylinderCylinderCollider">
            <summary>Contains all Cylinder-to-Cylinder interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.CylinderCylinderCollider.CheckContact(Microsoft.Xna.Framework.Matrix,System.Single,System.Single,Microsoft.Xna.Framework.Matrix,System.Single,System.Single)">
            <summary>Test whether an axis aligned box and a cylinder are overlapping</summary>
            <param name="firstTransform">Center and orientation of the first cylinder</param>
            <param name="firstLength">Length of the first cylinder</param>
            <param name="firstRadius">Radius of the first cylinder</param>
            <param name="secondTransform">Center and orientation of the second cylinder</param>
            <param name="secondLength">Length of the second cylinder</param>
            <param name="secondRadius">Radius of the second cylinder</param>
            <returns>True if the cylinder and the box are intersecting each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.CylinderCylinderCollider.FindContact(Microsoft.Xna.Framework.Matrix,System.Single,System.Single,Microsoft.Xna.Framework.Matrix,System.Single,System.Single)">
            <summary>Find the contact location between a cylinder and axis aligned box</summary>
            <param name="firstTransform">Center and orientation of the first cylinder</param>
            <param name="firstLength">Length of the first cylinder</param>
            <param name="firstRadius">Radius of the first cylinder</param>
            <param name="secondTransform">Center and orientation of the second cylinder</param>
            <param name="secondLength">Length of the second cylinder</param>
            <param name="secondRadius">Radius of the second cylinder</param>
            <returns>A contact location if the cylinder touches the axis aligned box</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.CylinderCylinderColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.CylinderMeshCollider">
            <summary>Contains all Cylinder-to-Mesh interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.CylinderMeshCollider.CheckContact(Microsoft.Xna.Framework.Matrix,System.Single,System.Single,Nuclex.Geometry.Volumes.TriangleMesh3)">
            <summary>Test whether a cylinder and a mesh are overlapping</summary>
            <param name="cylinderTransform">Center and orientation of the cylinder</param>
            <param name="cylinderLength">Length of the cylinder</param>
            <param name="cylinderRadius">Radius of the cylinder</param>
            <param name="triangleMesh">Mesh to be checked for overlap</param>
            <returns>True if the axis aligned box and the mesh are intersecting</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.CylinderMeshCollider.FindContact(Microsoft.Xna.Framework.Matrix,System.Single,System.Single,Nuclex.Geometry.Volumes.TriangleMesh3)">
            <summary>Find the contact location between a cylinder and a mesh</summary>
            <param name="cylinderTransform">Center and orientation of the cylinder</param>
            <param name="cylinderLength">Length of the cylinder</param>
            <param name="cylinderRadius">Radius of the cylinder</param>
            <param name="triangleMesh">Mesh to be checked for overlap</param>
            <returns>A contact location if the axis aligned box touches the mesh</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.CylinderMeshColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.CylinderObbCollider">
            <summary>Contains all Cylinder-to-Obb interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.CylinderObbCollider.CheckContact(Microsoft.Xna.Framework.Matrix,System.Single,System.Single,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Test whether a cylinder and an OBB are overlapping</summary>
            <param name="cylinderTransform">Center and orientation of the cylinder</param>
            <param name="cylinderLength">Length of the cylinder</param>
            <param name="cylinderRadius">Radius of the cylinder</param>
            <param name="obbTransform">Position and orientation of the OBB</param>
            <param name="obbExtents">Extents of the OBB</param>
            <returns>True if the cylinder and the OBB are intersecting</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.CylinderObbCollider.FindContact(Microsoft.Xna.Framework.Matrix,System.Single,System.Single,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Find the contact location between a cylinder and an OBB</summary>
            <param name="cylinderTransform">Center and orientation of the cylinder</param>
            <param name="cylinderLength">Length of the cylinder</param>
            <param name="cylinderRadius">Radius of the cylinder</param>
            <param name="obbTransform">Position and orientation of the OBB</param>
            <param name="obbExtents">Extents of the OBB</param>
            <returns>A contact location if the cylinder touches the OBB</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.CylinderObbColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.CylinderSphereCollider">
            <summary>Contains all Cylinder-to-Sphere interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.CylinderSphereCollider.CheckContact(Microsoft.Xna.Framework.Matrix,System.Single,System.Single,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Tests whether a cylinder is touching a sphere</summary>
            <param name="cylinderTransform">Orientation and position of the cylinder</param>
            <param name="cylinderRadius">The cylinder's radius</param>
            <param name="cylinderLength">The cylinder's length</param>
            <param name="sphereCenter">Location of the sphere's center</param>
            <param name="sphereRadius">The sphere's radius</param>
            <returns>True if the objects are touching each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.CylinderSphereCollider.FindContact(Microsoft.Xna.Framework.Matrix,System.Single,System.Single,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Find the contact location between a cylinder and a sphere</summary>
            <param name="cylinderTransform">Orientation and position of the cylinder</param>
            <param name="cylinderRadius">The cylinder's radius</param>
            <param name="cylinderLength">The cylinder's length</param>
            <param name="sphereCenter">Location of the sphere's center</param>
            <param name="sphereRadius">The sphere's radius</param>
            <returns>A contact location if the cylinder touches the sphere</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.CylinderSphereColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.CylinderSphereColliderTest.TestCheckContact">
            <summary>Tests the cylinder/sphere contact checking </summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.MeshMeshCollider">
            <summary>Contains all Mesh-to-Mesh interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.MeshMeshCollider.CheckContact(Nuclex.Geometry.Volumes.TriangleMesh3,Nuclex.Geometry.Volumes.TriangleMesh3)">
            <summary>Test whether a two meshes are overlapping</summary>
            <param name="firstMesh">First mesh to be checked for overlap</param>
            <param name="secondMesh">Second mesh to be checked for overlap</param>
            <returns>True if the two meshes are intersecting</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.MeshMeshCollider.FindContact(Nuclex.Geometry.Volumes.TriangleMesh3,Nuclex.Geometry.Volumes.TriangleMesh3)">
            <summary>Find the contact location between two meshes</summary>
            <param name="firstMesh">First mesh to be checked for overlap</param>
            <param name="secondMesh">Second mesh to be checked for overlap</param>
            <returns>A contact location if the two meshes touch each other</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.MeshMeshColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.MeshObbCollider">
            <summary>Contains all Mesh-to-Obb interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.MeshObbCollider.CheckContact(Nuclex.Geometry.Volumes.TriangleMesh3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Test whether a mesh and an OBB are overlapping</summary>
            <param name="triangleMesh">Mesh to be checked for intersection</param>
            <param name="obbTransform">Position and orientation of the OBB</param>
            <param name="obbExtents">Extents of the OBB</param>
            <returns>True if the mesh and the OBB are intersecting</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.MeshObbCollider.FindContact(Nuclex.Geometry.Volumes.TriangleMesh3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Find the contact location between a mesh and an OBB</summary>
            <param name="triangleMesh">Mesh to be checked for intersection</param>
            <param name="obbTransform">Position and orientation of the OBB</param>
            <param name="obbExtents">Extents of the OBB</param>
            <returns>A contact location if the mesh touches the OBB</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.MeshObbColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.MeshSphereCollider">
            <summary>Contains all Mesh-to-Sphere interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.MeshSphereCollider.CheckContact(Nuclex.Geometry.Volumes.TriangleMesh3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Test whether a mesh and a sphere are overlapping</summary>
            <param name="triangleMesh">Mesh to be checked for intersection</param>
            <param name="sphereCenter">Center of the sphere to be checked</param>
            <param name="sphereRadius">Radius of the sphere to be checked</param>
            <returns>True if the cylinder and the OBB are intersecting</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.MeshSphereCollider.FindContact(Nuclex.Geometry.Volumes.TriangleMesh3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Find the contact location between a cylinder and an OBB</summary>
            <param name="triangleMesh">Mesh to be checked for intersection</param>
            <param name="sphereCenter">Center of the sphere to be checked</param>
            <param name="sphereRadius">Radius of the sphere to be checked</param>
            <returns>A contact location if the cylinder touches the OBB</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.MeshSphereColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.ObbObbCollider">
            <summary>Contains all Obb-to-Obb interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.ObbObbCollider.CheckContact(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Test whether two oriented boxes intersect with each other</summary>
            <param name="firstBoxTransform">Orientation and position of the first box</param>
            <param name="firstBoxExtents">Extents of the first box to test</param>
            <param name="secondBoxTransform">Orientation and position of the second box</param>
            <param name="secondBoxExtents">Extents of the second box to test</param>
            <returns>True if the oriented boxes are overlapping</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.ObbObbCollider.FindContact(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Find the contact location between two oriented boxes</summary>
            <param name="firstBoxTransform">Orientation and position of the first box</param>
            <param name="firstBoxExtents">Extents of the first box to test</param>
            <param name="secondBoxTransform">Orientation and position of the second box</param>
            <param name="secondBoxExtents">Extents of the second box to test</param>
            <returns>A contact location if the two OBBs are touching each other</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.ObbObbColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.ObbSphereCollider">
            <summary>Contains all Obb-to-Sphere interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.ObbSphereCollider.CheckContact(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Test whether an oriented box and a sphere intersect each other</summary>
            <param name="boxTransform">Orientation and position of the box</param>
            <param name="boxExtents">Extents of the box to be tested</param>
            <param name="sphereCenter">Center of the sphere relative to the box' center</param>
            <param name="sphereRadius">Radius of the sphere</param>
            <returns>True if the sphere overlaps with the oriented box</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.ObbSphereCollider.FindContact(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Find the contact location between an OBB and a sphere</summary>
            <param name="boxTransform">Orientation and position of the box</param>
            <param name="boxExtents">Extents of the box to be tested</param>
            <param name="sphereCenter">Center of the sphere relative to the box' center</param>
            <param name="sphereRadius">Radius of the sphere</param>
            <returns>A contact location if the OBB and the sphere are intersecting</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.ObbSphereColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.SphereSphereCollider">
            <summary>Contains all Sphere-to-Sphere interference detection code</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.SphereSphereCollider.CheckContact(Microsoft.Xna.Framework.Vector3,System.Double,Microsoft.Xna.Framework.Vector3,System.Double)">
            <summary>Test whether two spheres intersect with each other</summary>
            <param name="firstCenter">Center of the first sphere to test</param>
            <param name="firstRadius">Radius of the first sphere</param>
            <param name="secondCenter">Center of the second sphere to test</param>
            <param name="secondRadius">Radius of the second sphere</param>
            <returns>True if the spheres intersect each other</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.SphereSphereCollider.FindContact(Microsoft.Xna.Framework.Vector3,System.Double,Microsoft.Xna.Framework.Vector3,System.Double)">
            <summary>Locate where two spheres intersect with each other</summary>
            <param name="firstCenter">Center of the first sphere to test</param>
            <param name="firstRadius">Radius of the first sphere</param>
            <param name="secondCenter">Center of the second sphere to test</param>
            <param name="secondRadius">Radius of the second sphere</param>
            <returns>A point in the center of the intersection, if any</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Collisions.SphereSphereColliderTest">
            <summary>Test for the AABB interference detection routines</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Collisions.SphereSphereColliderTest.TestCheckContact">
            <summary>Tests intersection between two spheres</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Cylinder3">
            <summary>Three-dimensional cylinder with arbitrary orientation</summary>
            <remarks>
              With an identity matrix, the cylinder extents along the Y axis in both directions,
              the translational part of the matrix will be equivalent to the cylinder's center.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.#ctor(Microsoft.Xna.Framework.Matrix,System.Single,System.Single)">
            <summary>Initializes a new instance of the cylinder</summary>
            <param name="transform">Orientation and position of cylinder</param>
            <param name="radius">The radius of the cylinder</param>
            <param name="length">The length of the cylinder</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.#ctor(Nuclex.Geometry.Volumes.Cylinder3)">
            <summary>Initializes a new cylinder as copy of an existing cylinder</summary>
            <param name="other">Existing cylinder that will be copied</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.Accept(Nuclex.Geometry.Volumes.VolumeVisitor)">
            <summary>Accepts a visitor to access the concrete volume implementation</summary>
            <param name="visitor">Visitor to be accepted</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the volume to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the volume to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.Intersects(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines if the volume clips the circle</summary>
            <param name="sphere">Circle that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.Intersects(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines if the volume clips the axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.Intersects(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines if the volume clips the box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.RandomPointOnSurface(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the volume's surface</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the volume's surface</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point within the volume</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point within the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.op_Equality(Nuclex.Geometry.Volumes.Cylinder3,Nuclex.Geometry.Volumes.Cylinder3)">
            <summary>Determines if two oriented boxes are equal</summary>
            <param name="first">First oriented box to be compared</param>
            <param name="second">Second oriented box to be compared</param>
            <returns>True if both axis oriented are equal</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.op_Inequality(Nuclex.Geometry.Volumes.Cylinder3,Nuclex.Geometry.Volumes.Cylinder3)">
            <summary>Determines if two oriented boxes are unequal</summary>
            <param name="first">First oriented box to be compared</param>
            <param name="second">Second oriented box to be compared</param>
            <returns>True if both oriented boxes are unequal</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.Equals(System.Object)">
            <summary>Determines if an object is identical to the oriented box</summary>
            <param name="obj">Object to compare to</param>
            <returns>True if the object is identical to the oriented box</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.GetHashCode">
            <summary>Builds a hashing code for the instance</summary>
            <returns>The instance's hashing code</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.ToString">
            <summary>Converts the cylinder to a readable string representation</summary>
            <returns>The cylinder as a string</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3.GetClosestPoint(System.Single,System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>Determines the closest point in the cylinder to another point</summary>
            <param name="cylinderRadius">The cylinder's radius</param>
            <param name="cylinderLength">The cylinder's length</param>
            <param name="location">Location to which to determine the closest point</param>
            <returns>The closest point to the given location</returns>
            <remarks>
              <para>
                This method works entirely in the cylinder's coordinate frame. To use
                this function on a cylinder that is not axis-aligned, translate the
                reference location into the cylinder's coordinate frame before and
                apply the cylinder's transformation matrix to the result.
              </para>
              <para>
                This design decision allows algorithms which are not interested in
                rotating the resulting closest point back into the global coodinate frame
                to save some time (think of intersection tests as an example). For a
                convenient closest point determination see the appropriate instance
                method of this class.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.Cylinder3.Transform">
            <summary>Orientation of the cylinder in 3D space</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.Cylinder3.Radius">
            <summary>Radius of the cylinder</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.Cylinder3.Height">
            <summary>Length of the cylinder</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Cylinder3.BoundingBox">
            <summary>Smallest box that encloses the volume in its entirety</summary>
            <remarks>
              This always produces an optimal box which means a tight-fitting box is generated
              that will touch the volume on each of its six sides. As a side effect, it is very
              likely that this box needs to be recalculated whenever the volume changes its
              orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Cylinder3.BoundingSphere">
            <summary>Smallest sphere that encloses the volume in its entirety</summary>
            <remarks>
              Bounding spheres have the advantage to not change even when the volume is
              rotated. That makes them ideal for dynamic objects that are not keeping their
              original orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Cylinder3.Mass">
            <summary>Amount of mass that the volume contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Cylinder3.SurfaceArea">
            <summary>The volume's total surface area</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Cylinder3.CenterOfMass">
            <summary>Center of the volume's mass</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Cylinder3.InertiaTensor">
            <summary>The inertia tensor matrix of the volume</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Cylinder3.Center">
            <summary>Location of the cylinder's center</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Cylinder3Test">
            <summary>Test for the three-dimensional box implementation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3Test.TestMassProperties">
            <summary>Tests whether the mass properties of the volume are working</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3Test.TestBoundingBox">
            <summary>Tests the bounding box generator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Cylinder3Test.TestBoundingSphere">
            <summary>Tests the bounding sphere generator</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.ContactPoint">
            <summary>A point of contact between two volumes</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.ContactPoint.Location">
            <summary>The absolute location where the contact occurs</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.ContactPoint.Time">
            <summary>The time at which the contact occurs</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.PointGenerators.AabbPointGenerator">
            <summary>Point generator for axis aligned box volumes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.PointGenerators.AabbPointGenerator.GenerateRandomPointOnSurface(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a random point on the surface of a box</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="extents">Extents of the box</param>
            <returns>A random point on the box' surface</returns>
            <remarks>
              The performance of this algorithm varies slightly depending on the face
              that is chosen for the random point because a different number of
              comparisons and subtractions will be performed.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.PointGenerators.AabbPointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a random point within a box</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="extents">Extents of the box</param>
            <returns>A random point within the box</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.PointGenerators.CylinderPointGenerator">
            <summary>Point generator for cylinder volumes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.PointGenerators.CylinderPointGenerator.GenerateRandomPointOnSurface(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Matrix,System.Single,System.Single)">
            <summary>Returns a random point on the surface of a cylinder</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="orientation">Orientation of the cylinder</param>
            <param name="radius">Radius of the cylinder</param>
            <param name="length">Length of the cylinder</param>
            <returns>A random point on the volume's surface</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.PointGenerators.CylinderPointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Matrix,System.Single,System.Single)">
            <summary>Returns a random point within a cylinder</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="orientation">Orientation of the cylinder</param>
            <param name="radius">Radius of the cylinder</param>
            <param name="length">Length of the cylinder</param>
            <returns>A random point within the cylinder</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.PointGenerators.ObbPointGenerator">
            <summary>Point generator for oriented volumes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.PointGenerators.ObbPointGenerator.GenerateRandomPointOnSurface(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a random point on the surface of a box</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="orientation">Orientation of the box</param>
            <param name="extents">Extents of the box</param>
            <returns>A random point on the box's surface</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.PointGenerators.ObbPointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
            <summary>Returns a random point within the box</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="orientation">Orientation of the box</param>
            <param name="extents">Extents of the box</param>
            <returns>A random point within the box</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.PointGenerators.SpherePointGenerator">
            <summary>Point generator for sphere volumes</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.PointGenerators.SpherePointGenerator.GenerateRandomPointOnSurface(Nuclex.Geometry.IRandom,System.Single)">
            <summary>Returns a random point on the surface of a sphere</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="radius">Radius of the sphere</param>
            <returns>A random point on the sphere's surface</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.PointGenerators.SpherePointGenerator.GenerateRandomPointWithin(Nuclex.Geometry.IRandom,System.Single)">
            <summary>Returns a random point within a sphere</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <param name="radius">Radius of the sphere</param>
            <returns>A random point with the sphere</returns>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Sphere3">
            <summary>A two-dimensional circle</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.#ctor(Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>Initializes a new sphere</summary>
            <param name="center">The center of the circle</param>
            <param name="radius">Radius the circle will have</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.#ctor(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Initializes a new sphere as copy of an existing sphere</summary>
            <param name="other">Existing sphere that will be copied</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.Accept(Nuclex.Geometry.Volumes.VolumeVisitor)">
            <summary>Accepts a visitor to access the concrete volume implementation</summary>
            <param name="visitor">Visitor to be accepted</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the volume to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the volume to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.Contains(Microsoft.Xna.Framework.Vector3)">
            <summary>Determines whether a point is inside the sphere</summary>
            <param name="point">Point to be checked</param>
            <returns>True if the point lies within the sphere</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.Intersects(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines if the volume clips the circle</summary>
            <param name="sphere">Circle that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.Intersects(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines if the volume clips the axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.Intersects(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines if the volume clips the box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.RandomPointOnSurface(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the volume's surface</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the volume's surface</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point within the volume</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point within the volume</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.LocateImpact(Microsoft.Xna.Framework.Vector3,Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines if the volume will impact on a sphere</summary>
            <param name="thisVelocity">Velocity with which this volume is moving</param>
            <param name="sphere">Sphere that will be checked for intersection</param>
            <returns>The point of first contact, if any</returns>
            <remarks>
              <para>
                Conventional tests that resort to stepping often fail to detect collisions
                between fast-moving objects. This impact determination test will always
                detect a collision if it occurs, giving the exact time of the impact.
              </para>
              <para>
                This is a simplified test that assumes a linear trajectory and does
                not take off-center object rotation into account. It is well suited to use
                on two bounding spheres in order to determine if a collision between the
                shape contained is possible at all.
              </para>
              <para>
                Ideas taken from the "Simple Intersection Tests for Games" article
                on gamasutra by Gomez.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.op_Equality(Nuclex.Geometry.Volumes.Sphere3,Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines if two spheres are equal</summary>
            <param name="first">First sphere to be compared</param>
            <param name="second">Second sphere to be compared</param>
            <returns>True if both spheres are equal</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.op_Inequality(Nuclex.Geometry.Volumes.Sphere3,Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines if two spheres are unequal</summary>
            <param name="first">First sphere to be compared</param>
            <param name="second">Second sphere to be compared</param>
            <returns>True if both spheres are unequal</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.Equals(System.Object)">
            <summary>Determines if an object is identical to the sphere</summary>
            <param name="obj">Object to compare to</param>
            <returns>True if the object is identical to the sphere</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.GetHashCode">
            <summary>Builds a hashing code for the instance</summary>
            <returns>The instance's hashing code</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3.ToString">
            <summary>Converts the sphere to a readable string representation</summary>
            <returns>The sphere as a string</returns>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.Sphere3.Center">
            <summary>The center of the circle</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.Sphere3.Radius">
            <summary>Radius of the circle</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Sphere3.BoundingBox">
            <summary>Smallest box that encloses the volume in its entirety</summary>
            <remarks>
              This always produces an optimal box which means a tight-fitting box is generated
              that will touch the volume on each of its six sides. As a side effect, it is very
              likely that this box needs to be recalculated whenever the volume changes its
              orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Sphere3.BoundingSphere">
            <summary>Smallest sphere that encloses the volume in its entirety</summary>
            <remarks>
              Bounding spheres have the advantage to not change even when the volume is
              rotated. That makes them ideal for dynamic objects that are not keeping their
              original orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Sphere3.Mass">
            <summary>Amount of mass that the volume contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Sphere3.SurfaceArea">
            <summary>The volume's total surface area</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Sphere3.CenterOfMass">
            <summary>Center of the volume's mass</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.Sphere3.InertiaTensor">
            <summary>The inertia tensor matrix of the volume</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.Sphere3Test">
            <summary>Test for the sphere (3D) implementation</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3Test.TestMassProperties">
            <summary>Tests whether the mass properties of the volume are working</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3Test.TestMovingSphereIntersection">
            <summary>Tests the intersection query on moving spheres</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3Test.TestBoundingBox">
            <summary>Tests the bounding box generator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3Test.TestBoundingSphere">
            <summary>Tests the bounding sphere generator</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.Sphere3Test.TestRandomPointOnSurface">
            <summary>Tests the random points on surface function</summary>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.TriangleMesh3">
            <summary>Three-dimensional triangle mesh</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.#ctor(Microsoft.Xna.Framework.Vector3[])">
            <summary>Initializes a triangle mesh from a sequentiel list of triangles</summary>
            <param name="vertices">Array of vertices to construct triangles from</param>
            <remarks>
              This variant of the constructor generates a mesh from the vertex array by
              building triangles of every three vertices in the list. The triangles are
              required to form a closed, convex hull.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[])">
            <summary>Initializes a triangle mesh from an indexed list of triangles</summary>
            <param name="vertices">Vertices to construct triangles from</param>
            <param name="indices">Indices to the vertices to construct triangles from</param>
            <remarks>
              This variant of the constructor generates a mesh from the vertex array by
              taking every three indices in the index array and then generating a triangle
              by the three vertices with the given index. The triangles are required to
              form a closed, convex hull.
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.Accept(Nuclex.Geometry.Volumes.VolumeVisitor)">
            <summary>Accepts a visitor to access the concrete volume implementation</summary>
            <param name="visitor">Visitor to be accepted</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.ClosestPointTo(Microsoft.Xna.Framework.Vector3)">
            <summary>Locates the nearest point in the volume to some arbitrary location</summary>
            <param name="location">Location to which the closest point is determined</param>
            <returns>The closest point in the volume to the specified location</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.Intersects(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Determines if the volume clips the circle</summary>
            <param name="sphere">Circle that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.Intersects(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Determines if the volume clips the axis aligned box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.Intersects(Nuclex.Geometry.Volumes.Box3)">
            <summary>Determines if the volume clips the box</summary>
            <param name="box">Box that will be checked for intersection</param>
            <returns>True if the objects overlap</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.RandomPointOnSurface(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point on the volume's surface</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point on the volume's surface</returns>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.RandomPointWithin(Nuclex.Geometry.IRandom)">
            <summary>Returns a random point within the volume</summary>
            <param name="randomNumberGenerator">Random number generator that will be used</param>
            <returns>A random point within the volume</returns>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.TriangleMesh3.Transform">
            <summary>Orientation as position of the mesh in space</summary>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.computeMassProperties">
            <summary>Compute or recompute the mass properties of this triangle mesh</summary>
            <remarks>
              <para>
                The code has been translated to C# from David Eberly's document titled
                "Polyhedral Mass Properties (Revisited)" which is in turn based on
                Brian Mirtich's "Fast and accurate computation of polyhedral mass properties".
                You can find David Eberly's document at
                  http://www.geometrictools.com/Documentation/PolyhedralMassProperties.pdf
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.TriangleMesh3.generateIndices(System.Int32)">
            <summary>Generates sequential indices for a triangle vertex array</summary>
            <param name="count">Number of indices to generate</param>
            <returns>An array containing sequential indices</returns>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.TriangleMesh3.Vertices">
            <summary>The vertices that make up the mesh</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.TriangleMesh3.Indices">
            <summary>Indices of the vertices from which to build triangles</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.TriangleMesh3.surfaceArea">
            <summary>Total amount of surface area of this mesh</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.TriangleMesh3.centerOfMass">
            <summary>The center of mass in mesh coordinates</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.TriangleMesh3.mass">
            <summary>The mass of this mesh assuming a material density of 1.0</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.TriangleMesh3.inertiaTensor">
            <summary>The meshes inertia tensor matrix, useful for physics calculations</summary>
        </member>
        <member name="F:Nuclex.Geometry.Volumes.TriangleMesh3.accumulatedTriangleSurface">
            <summary>Accumulated surface of the triangles in this mesh</summary>
            <remarks>
              This is used to perform a binary search in the RandomPointOnSurface() method
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.TriangleMesh3.BoundingBox">
            <summary>Smallest box that encloses the volume in its entirety</summary>
            <remarks>
              This always produces an optimal box which means a tight-fitting box is generated
              that will touch the volume on each of its six sides. As a side effect, it is very
              likely that this box needs to be recalculated whenever the volume changes its
              orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.TriangleMesh3.BoundingSphere">
            <summary>Smallest sphere that encloses the volume in its entirety</summary>
            <remarks>
              Bounding spheres have the advantage to not change even when the volume is
              rotated. That makes them ideal for dynamic objects that are not keeping their
              original orientation.
            </remarks>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.TriangleMesh3.Mass">
            <summary>Amount of mass that the volume contains</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.TriangleMesh3.SurfaceArea">
            <summary>The volume's total surface area</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.TriangleMesh3.CenterOfMass">
            <summary>Center of the volume's mass</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.TriangleMesh3.InertiaTensor">
            <summary>The inetria tensor matrix of the volume</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.TriangleMesh3.Triangles">
            <summary>Enumerates the triangles contained in the mesh</summary>
        </member>
        <member name="P:Nuclex.Geometry.Volumes.TriangleMesh3.Location">
            <summary>Location at which mesh is placed in space</summary>
            <remarks>
              This doesn't take the center of mass or any other physical property into account,
              it's merely an offset for the original vertex coordinates. Otherwise you would have
              a hard time aligning your physical mesh with the visual one :)
            </remarks>
        </member>
        <member name="T:Nuclex.Geometry.Volumes.VolumeVisitor">
            <summary>Base class for volume visitors</summary>
            <remarks>
              See the visitor pattern. 
              <para>
                If you need to perform work on a volume whose type you do not know, you could
                of course just create a set of if(volume is ...) queries. However, you would
                have to manually track down all these queries should a future version of this
                library provide a new type of volume.
              </para>
              <para>
                Your other option is to create a special class that does your work which derives
                from this VolumeVisitor class. It will elegantly resolve the volume type by
                calling into the volume (resolving the type via the vtable) which then calls
                the visitor's distinctive method for the exact kind of volume. If a new volume
                is introduced to the library, it will be added to the VolumeVisitor class and
                your compiler will point out to you where you need to extend your code for the
                new kind of volume because the abstract method will not yet be implemented there.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.VolumeVisitor.Visit(Nuclex.Geometry.Volumes.IVolume3)">
            <summary>Visit a volume and do the action the visitor is intended for</summary>
            <param name="volume">Volume to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.VolumeVisitor.Visit(Nuclex.Geometry.Volumes.AxisAlignedBox3)">
            <summary>Visit an axis aligned box</summary>
            <param name="box">Box to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.VolumeVisitor.Visit(Nuclex.Geometry.Volumes.Box3)">
            <summary>Visit an oriented box</summary>
            <param name="box">Box to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.VolumeVisitor.Visit(Nuclex.Geometry.Volumes.Sphere3)">
            <summary>Visit a sphere</summary>
            <param name="sphere">Sphere to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.VolumeVisitor.Visit(Nuclex.Geometry.Volumes.Cylinder3)">
            <summary>Visit a cylinder</summary>
            <param name="cylinder">Cylinder to visit</param>
        </member>
        <member name="M:Nuclex.Geometry.Volumes.VolumeVisitor.Visit(Nuclex.Geometry.Volumes.TriangleMesh3)">
            <summary>Visit a triangle mesh</summary>
            <param name="mesh">Mesh to visit</param>
        </member>
    </members>
</doc>
